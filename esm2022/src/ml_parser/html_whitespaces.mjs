/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as html from './ast';
import { NGSP_UNICODE } from './entities';
import { ParseTreeResult } from './parser';
export const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';
const SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);
// Equivalent to \s with \u00a0 (non-breaking space) excluded.
// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
const WS_CHARS = ' \f\n\r\t\v\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff';
const NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);
const WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');
function hasPreserveWhitespacesAttr(attrs) {
    return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);
}
/**
 * &ngsp; is a placeholder for non-removable space
 * &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character
 * and later on replaced by a space.
 */
export function replaceNgsp(value) {
    // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE
    return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');
}
/**
 * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:
 * - consider spaces, tabs and new lines as whitespace characters;
 * - drop text nodes consisting of whitespace characters only;
 * - for all other text nodes replace consecutive whitespace characters with one space;
 * - convert &ngsp; pseudo-entity to a single space;
 *
 * Removal and trimming of whitespaces have positive performance impact (less code to generate
 * while compiling templates, faster view creation). At the same time it can be "destructive"
 * in some cases (whitespaces can influence layout). Because of the potential of breaking layout
 * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for
 * whitespace removal. The default option for whitespace removal will be revisited in Angular 6
 * and might be changed to "on" by default.
 *
 * If `originalNodeMap` is provided, the transformed nodes will be mapped back to their original
 * inputs. Any output nodes not in the map were not transformed. This supports correlating and
 * porting information between the trimmed nodes and original nodes (such as `i18n` properties)
 * such that trimming whitespace does not does not drop required information from the node.
 */
export class WhitespaceVisitor {
    constructor(preserveSignificantWhitespace, originalNodeMap, requireContext = true) {
        this.preserveSignificantWhitespace = preserveSignificantWhitespace;
        this.originalNodeMap = originalNodeMap;
        this.requireContext = requireContext;
        // How many ICU expansions which are currently being visited. ICUs can be nested, so this
        // tracks the current depth of nesting. If this depth is greater than 0, then this visitor is
        // currently processing content inside an ICU expansion.
        this.icuExpansionDepth = 0;
    }
    visitElement(element, context) {
        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
            // don't descent into elements where we need to preserve whitespaces
            // but still visit all attributes to eliminate one used as a market to preserve WS
            const newElement = new html.Element(element.name, visitAllWithSiblings(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            this.originalNodeMap?.set(newElement, element);
            return newElement;
        }
        const newElement = new html.Element(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        this.originalNodeMap?.set(newElement, element);
        return newElement;
    }
    visitAttribute(attribute, context) {
        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
    }
    visitText(text, context) {
        const isNotBlank = text.value.match(NO_WS_REGEXP);
        const hasExpansionSibling = context && (context.prev instanceof html.Expansion || context.next instanceof html.Expansion);
        // Do not trim whitespace within ICU expansions when preserving significant whitespace.
        // Historically, ICU whitespace was never trimmed and this is really a bug. However fixing it
        // would change message IDs which we can't easily do. Instead we only trim ICU whitespace within
        // ICU expansions when not preserving significant whitespace, which is the new behavior where it
        // most matters.
        const inIcuExpansion = this.icuExpansionDepth > 0;
        if (inIcuExpansion && this.preserveSignificantWhitespace)
            return text;
        if (isNotBlank || hasExpansionSibling) {
            // Process the whitespace in the tokens of this Text node
            const tokens = text.tokens.map((token) => token.type === 5 /* TokenType.TEXT */ ? createWhitespaceProcessedTextToken(token) : token);
            // Fully trim message when significant whitespace is not preserved.
            if (!this.preserveSignificantWhitespace && tokens.length > 0) {
                // The first token should only call `.trimStart()` and the last token
                // should only call `.trimEnd()`, but there might be only one token which
                // needs to call both.
                const firstToken = tokens[0];
                tokens.splice(0, 1, trimLeadingWhitespace(firstToken, context));
                const lastToken = tokens[tokens.length - 1]; // Could be the same as the first token.
                tokens.splice(tokens.length - 1, 1, trimTrailingWhitespace(lastToken, context));
            }
            // Process the whitespace of the value of this Text node. Also trim the leading/trailing
            // whitespace when we don't need to preserve significant whitespace.
            const processed = processWhitespace(text.value);
            const value = this.preserveSignificantWhitespace
                ? processed
                : trimLeadingAndTrailingWhitespace(processed, context);
            const result = new html.Text(value, text.sourceSpan, tokens, text.i18n);
            this.originalNodeMap?.set(result, text);
            return result;
        }
        return null;
    }
    visitComment(comment, context) {
        return comment;
    }
    visitExpansion(expansion, context) {
        this.icuExpansionDepth++;
        let newExpansion;
        try {
            newExpansion = new html.Expansion(expansion.switchValue, expansion.type, visitAllWithSiblings(this, expansion.cases), expansion.sourceSpan, expansion.switchValueSourceSpan, expansion.i18n);
        }
        finally {
            this.icuExpansionDepth--;
        }
        this.originalNodeMap?.set(newExpansion, expansion);
        return newExpansion;
    }
    visitExpansionCase(expansionCase, context) {
        const newExpansionCase = new html.ExpansionCase(expansionCase.value, visitAllWithSiblings(this, expansionCase.expression), expansionCase.sourceSpan, expansionCase.valueSourceSpan, expansionCase.expSourceSpan);
        this.originalNodeMap?.set(newExpansionCase, expansionCase);
        return newExpansionCase;
    }
    visitBlock(block, context) {
        const newBlock = new html.Block(block.name, block.parameters, visitAllWithSiblings(this, block.children), block.sourceSpan, block.nameSpan, block.startSourceSpan, block.endSourceSpan);
        this.originalNodeMap?.set(newBlock, block);
        return newBlock;
    }
    visitBlockParameter(parameter, context) {
        return parameter;
    }
    visitLetDeclaration(decl, context) {
        return decl;
    }
    visit(_node, context) {
        // `visitAllWithSiblings` provides context necessary for ICU messages to be handled correctly.
        // Prefer that over calling `html.visitAll` directly on this visitor.
        if (this.requireContext && !context) {
            throw new Error(`WhitespaceVisitor requires context. Visit via \`visitAllWithSiblings\` to get this context.`);
        }
        return false;
    }
}
function trimLeadingWhitespace(token, context) {
    if (token.type !== 5 /* TokenType.TEXT */)
        return token;
    const isFirstTokenInTag = !context?.prev;
    if (!isFirstTokenInTag)
        return token;
    return transformTextToken(token, (text) => text.trimStart());
}
function trimTrailingWhitespace(token, context) {
    if (token.type !== 5 /* TokenType.TEXT */)
        return token;
    const isLastTokenInTag = !context?.next;
    if (!isLastTokenInTag)
        return token;
    return transformTextToken(token, (text) => text.trimEnd());
}
function trimLeadingAndTrailingWhitespace(text, context) {
    const isFirstTokenInTag = !context?.prev;
    const isLastTokenInTag = !context?.next;
    const maybeTrimmedStart = isFirstTokenInTag ? text.trimStart() : text;
    const maybeTrimmed = isLastTokenInTag ? maybeTrimmedStart.trimEnd() : maybeTrimmedStart;
    return maybeTrimmed;
}
function createWhitespaceProcessedTextToken({ type, parts, sourceSpan }) {
    return { type, parts: [processWhitespace(parts[0])], sourceSpan };
}
function transformTextToken({ type, parts, sourceSpan }, transform) {
    // `TextToken` only ever has one part as defined in its type, so we just transform the first element.
    return { type, parts: [transform(parts[0])], sourceSpan };
}
function processWhitespace(text) {
    return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');
}
export function removeWhitespaces(htmlAstWithErrors, preserveSignificantWhitespace) {
    return new ParseTreeResult(visitAllWithSiblings(new WhitespaceVisitor(preserveSignificantWhitespace), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);
}
export function visitAllWithSiblings(visitor, nodes) {
    const result = [];
    nodes.forEach((ast, i) => {
        const context = { prev: nodes[i - 1], next: nodes[i + 1] };
        const astResult = ast.visit(visitor, context);
        if (astResult) {
            result.push(astResult);
        }
    });
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHRtbF93aGl0ZXNwYWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyL3NyYy9tbF9wYXJzZXIvaHRtbF93aGl0ZXNwYWNlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sQ0FBQztBQUM5QixPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFHekMsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQUcsdUJBQXVCLENBQUM7QUFFN0QsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBRXRGLDhEQUE4RDtBQUM5RCxtR0FBbUc7QUFDbkcsTUFBTSxRQUFRLEdBQUcsMEVBQTBFLENBQUM7QUFDNUYsTUFBTSxZQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQ2xELE1BQU0saUJBQWlCLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxRQUFRLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztBQUUvRCxTQUFTLDBCQUEwQixDQUFDLEtBQXVCO0lBQ3pELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQW9CLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUsscUJBQXFCLENBQUMsQ0FBQztBQUNuRixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQUMsS0FBYTtJQUN2QyxnRUFBZ0U7SUFDaEUsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsRUFB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b29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyBodG1sIGZyb20gJy4vYXN0JztcbmltcG9ydCB7TkdTUF9VTklDT0RFfSBmcm9tICcuL2VudGl0aWVzJztcbmltcG9ydCB7UGFyc2VUcmVlUmVzdWx0fSBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQge0ludGVycG9sYXRlZFRleHRUb2tlbiwgVGV4dFRva2VuLCBUb2tlblR5cGV9IGZyb20gJy4vdG9rZW5zJztcblxuZXhwb3J0IGNvbnN0IFBSRVNFUlZFX1dTX0FUVFJfTkFNRSA9ICduZ1ByZXNlcnZlV2hpdGVzcGFjZXMnO1xuXG5jb25zdCBTS0lQX1dTX1RSSU1fVEFHUyA9IG5ldyBTZXQoWydwcmUnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAnc2NyaXB0JywgJ3N0eWxlJ10pO1xuXG4vLyBFcXVpdmFsZW50IHRvIFxccyB3aXRoIFxcdTAwYTAgKG5vbi1icmVha2luZyBzcGFjZSkgZXhjbHVkZWQuXG4vLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHBcbmNvbnN0IFdTX0NIQVJTID0gJyBcXGZcXG5cXHJcXHRcXHZcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZic7XG5jb25zdCBOT19XU19SRUdFWFAgPSBuZXcgUmVnRXhwKGBbXiR7V1NfQ0hBUlN9XWApO1xuY29uc3QgV1NfUkVQTEFDRV9SRUdFWFAgPSBuZXcgUmVnRXhwKGBbJHtXU19DSEFSU31dezIsfWAsICdnJyk7XG5cbmZ1bmN0aW9uIGhhc1ByZXNlcnZlV2hpdGVzcGFjZXNBdHRyKGF0dHJzOiBodG1sLkF0dHJpYnV0ZVtdKTogYm9vbGVhbiB7XG4gIHJldHVybiBhdHRycy5zb21lKChhdHRyOiBodG1sLkF0dHJpYnV0ZSkgPT4gYXR0ci5uYW1lID09PSBQUkVTRVJWRV9XU19BVFRSX05BTUUpO1xufVxuXG4vKipcbiAqICZuZ3NwOyBpcyBhIHBsYWNlaG9sZGVyIGZvciBub24tcmVtb3ZhYmxlIHNwYWNlXG4gKiAmbmdzcDsgaXMgY29udmVydGVkIHRvIHRoZSAweEU1MDAgUFVBIChQcml2YXRlIFVzZSBBcmVhcykgdW5pY29kZSBjaGFyYWN0ZXJcbiAqIGFuZCBsYXRlciBvbiByZXBsYWNlZCBieSBhIHNwYWNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5nc3AodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIGxleGVyIGlzIHJlcGxhY2luZyB0aGUgJm5nc3A7IHBzZXVkby1lbnRpdHkgd2l0aCBOR1NQX1VOSUNPREVcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cChOR1NQX1VOSUNPREUsICdnJyksICcgJyk7XG59XG5cbi8qKlxuICogVGhpcyB2aXNpdG9yIGNhbiB3YWxrIEhUTUwgcGFyc2UgdHJlZSBhbmQgcmVtb3ZlIC8gdHJpbSB0ZXh0IG5vZGVzIHVzaW5nIHRoZSBmb2xsb3dpbmcgcnVsZXM6XG4gKiAtIGNvbnNpZGVyIHNwYWNlcywgdGFicyBhbmQgbmV3IGxpbmVzIGFzIHdoaXRlc3BhY2UgY2hhcmFjdGVycztcbiAqIC0gZHJvcCB0ZXh0IG5vZGVzIGNvbnNpc3Rpbmcgb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIG9ubHk7XG4gKiAtIGZvciBhbGwgb3RoZXIgdGV4dCBub2RlcyByZXBsYWNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB3aXRoIG9uZSBzcGFjZTtcbiAqIC0gY29udmVydCAmbmdzcDsgcHNldWRvLWVudGl0eSB0byBhIHNpbmdsZSBzcGFjZTtcbiAqXG4gKiBSZW1vdmFsIGFuZCB0cmltbWluZyBvZiB3aGl0ZXNwYWNlcyBoYXZlIHBvc2l0aXZlIHBlcmZvcm1hbmNlIGltcGFjdCAobGVzcyBjb2RlIHRvIGdlbmVyYXRlXG4gKiB3aGlsZSBjb21waWxpbmcgdGVtcGxhdGVzLCBmYXN0ZXIgdmlldyBjcmVhdGlvbikuIEF0IHRoZSBzYW1lIHRpbWUgaXQgY2FuIGJlIFwiZGVzdHJ1Y3RpdmVcIlxuICogaW4gc29tZSBjYXNlcyAod2hpdGVzcGFjZXMgY2FuIGluZmx1ZW5jZSBsYXlvdXQpLiBCZWNhdXNlIG9mIHRoZSBwb3RlbnRpYWwgb2YgYnJlYWtpbmcgbGF5b3V0XG4gKiB0aGlzIHZpc2l0b3IgaXMgbm90IGFjdGl2YXRlZCBieSBkZWZhdWx0IGluIEFuZ3VsYXIgNSBhbmQgcGVvcGxlIG5lZWQgdG8gZXhwbGljaXRseSBvcHQtaW4gZm9yXG4gKiB3aGl0ZXNwYWNlIHJlbW92YWwuIFRoZSBkZWZhdWx0IG9wdGlvbiBmb3Igd2hpdGVzcGFjZSByZW1vdmFsIHdpbGwgYmUgcmV2aXNpdGVkIGluIEFuZ3VsYXIgNlxuICogYW5kIG1pZ2h0IGJlIGNoYW5nZWQgdG8gXCJvblwiIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYG9yaWdpbmFsTm9kZU1hcGAgaXMgcHJvdmlkZWQsIHRoZSB0cmFuc2Zvcm1lZCBub2RlcyB3aWxsIGJlIG1hcHBlZCBiYWNrIHRvIHRoZWlyIG9yaWdpbmFsXG4gKiBpbnB1dHMuIEFueSBvdXRwdXQgbm9kZXMgbm90IGluIHRoZSBtYXAgd2VyZSBub3QgdHJhbnNmb3JtZWQuIFRoaXMgc3VwcG9ydHMgY29ycmVsYXRpbmcgYW5kXG4gKiBwb3J0aW5nIGluZm9ybWF0aW9uIGJldHdlZW4gdGhlIHRyaW1tZWQgbm9kZXMgYW5kIG9yaWdpbmFsIG5vZGVzIChzdWNoIGFzIGBpMThuYCBwcm9wZXJ0aWVzKVxuICogc3VjaCB0aGF0IHRyaW1taW5nIHdoaXRlc3BhY2UgZG9lcyBub3QgZG9lcyBub3QgZHJvcCByZXF1aXJlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBub2RlLlxuICovXG5leHBvcnQgY2xhc3MgV2hpdGVzcGFjZVZpc2l0b3IgaW1wbGVtZW50cyBodG1sLlZpc2l0b3Ige1xuICAvLyBIb3cgbWFueSBJQ1UgZXhwYW5zaW9ucyB3aGljaCBhcmUgY3VycmVudGx5IGJlaW5nIHZpc2l0ZWQuIElDVXMgY2FuIGJlIG5lc3RlZCwgc28gdGhpc1xuICAvLyB0cmFja3MgdGhlIGN1cnJlbnQgZGVwdGggb2YgbmVzdGluZy4gSWYgdGhpcyBkZXB0aCBpcyBncmVhdGVyIHRoYW4gMCwgdGhlbiB0aGlzIHZpc2l0b3IgaXNcbiAgLy8gY3VycmVudGx5IHByb2Nlc3NpbmcgY29udGVudCBpbnNpZGUgYW4gSUNVIGV4cGFuc2lvbi5cbiAgcHJpdmF0ZSBpY3VFeHBhbnNpb25EZXB0aCA9IDA7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBwcmVzZXJ2ZVNpZ25pZmljYW50V2hpdGVzcGFjZTogYm9vbGVhbixcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9yaWdpbmFsTm9kZU1hcD86IE1hcDxodG1sLk5vZGUsIGh0bWwuTm9kZT4sXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXF1aXJlQ29udGV4dCA9IHRydWUsXG4gICkge31cblxuICB2aXNpdEVsZW1lbnQoZWxlbWVudDogaHRtbC5FbGVtZW50LCBjb250ZXh0OiBhbnkpOiBhbnkge1xuICAgIGlmIChTS0lQX1dTX1RSSU1fVEFHUy5oYXMoZWxlbWVudC5uYW1lKSB8fCBoYXNQcmVzZXJ2ZVdoaXRlc3BhY2VzQXR0cihlbGVtZW50LmF0dHJzKSkge1xuICAgICAgLy8gZG9uJ3QgZGVzY2VudCBpbnRvIGVsZW1lbnRzIHdoZXJlIHdlIG5lZWQgdG8gcHJlc2VydmUgd2hpdGVzcGFjZXNcbiAgICAgIC8vIGJ1dCBzdGlsbCB2aXNpdCBhbGwgYXR0cmlidXRlcyB0byBlbGltaW5hdGUgb25lIHVzZWQgYXMgYSBtYXJrZXQgdG8gcHJlc2VydmUgV1NcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBuZXcgaHRtbC5FbGVtZW50KFxuICAgICAgICBlbGVtZW50Lm5hbWUsXG4gICAgICAgIHZpc2l0QWxsV2l0aFNpYmxpbmdzKHRoaXMsIGVsZW1lbnQuYXR0cnMpLFxuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLFxuICAgICAgICBlbGVtZW50LnNvdXJjZVNwYW4sXG4gICAgICAgIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLFxuICAgICAgICBlbGVtZW50LmVuZFNvdXJjZVNwYW4sXG4gICAgICAgIGVsZW1lbnQuaTE4bixcbiAgICAgICk7XG4gICAgICB0aGlzLm9yaWdpbmFsTm9kZU1hcD8uc2V0KG5ld0VsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3RWxlbWVudCA9IG5ldyBodG1sLkVsZW1lbnQoXG4gICAgICBlbGVtZW50Lm5hbWUsXG4gICAgICBlbGVtZW50LmF0dHJzLFxuICAgICAgdmlzaXRBbGxXaXRoU2libGluZ3ModGhpcywgZWxlbWVudC5jaGlsZHJlbiksXG4gICAgICBlbGVtZW50LnNvdXJjZVNwYW4sXG4gICAgICBlbGVtZW50LnN0YXJ0U291cmNlU3BhbixcbiAgICAgIGVsZW1lbnQuZW5kU291cmNlU3BhbixcbiAgICAgIGVsZW1lbnQuaTE4bixcbiAgICApO1xuICAgIHRoaXMub3JpZ2luYWxOb2RlTWFwPy5zZXQobmV3RWxlbWVudCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxuICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGU6IGh0bWwuQXR0cmlidXRlLCBjb250ZXh0OiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBhdHRyaWJ1dGUubmFtZSAhPT0gUFJFU0VSVkVfV1NfQVRUUl9OQU1FID8gYXR0cmlidXRlIDogbnVsbDtcbiAgfVxuXG4gIHZpc2l0VGV4dCh0ZXh0OiBodG1sLlRleHQsIGNvbnRleHQ6IFNpYmxpbmdWaXNpdG9yQ29udGV4dCB8IG51bGwpOiBhbnkge1xuICAgIGNvbnN0IGlzTm90QmxhbmsgPSB0ZXh0LnZhbHVlLm1hdGNoKE5PX1dTX1JFR0VYUCk7XG4gICAgY29uc3QgaGFzRXhwYW5zaW9uU2libGluZyA9XG4gICAgICBjb250ZXh0ICYmIChjb250ZXh0LnByZXYgaW5zdGFuY2VvZiBodG1sLkV4cGFuc2lvbiB8fCBjb250ZXh0Lm5leHQgaW5zdGFuY2VvZiBodG1sLkV4cGFuc2lvbik7XG5cbiAgICAvLyBEbyBub3QgdHJpbSB3aGl0ZXNwYWNlIHdpdGhpbiBJQ1UgZXhwYW5zaW9ucyB3aGVuIHByZXNlcnZpbmcgc2lnbmlmaWNhbnQgd2hpdGVzcGFjZS5cbiAgICAvLyBIaXN0b3JpY2FsbHksIElDVSB3aGl0ZXNwYWNlIHdhcyBuZXZlciB0cmltbWVkIGFuZCB0aGlzIGlzIHJlYWxseSBhIGJ1Zy4gSG93ZXZlciBmaXhpbmcgaXRcbiAgICAvLyB3b3VsZCBjaGFuZ2UgbWVzc2FnZSBJRHMgd2hpY2ggd2UgY2FuJ3QgZWFzaWx5IGRvLiBJbnN0ZWFkIHdlIG9ubHkgdHJpbSBJQ1Ugd2hpdGVzcGFjZSB3aXRoaW5cbiAgICAvLyBJQ1UgZXhwYW5zaW9ucyB3aGVuIG5vdCBwcmVzZXJ2aW5nIHNpZ25pZmljYW50IHdoaXRlc3BhY2UsIHdoaWNoIGlzIHRoZSBuZXcgYmVoYXZpb3Igd2hlcmUgaXRcbiAgICAvLyBtb3N0IG1hdHRlcnMuXG4gICAgY29uc3QgaW5JY3VFeHBhbnNpb24gPSB0aGlzLmljdUV4cGFuc2lvbkRlcHRoID4gMDtcbiAgICBpZiAoaW5JY3VFeHBhbnNpb24gJiYgdGhpcy5wcmVzZXJ2ZVNpZ25pZmljYW50V2hpdGVzcGFjZSkgcmV0dXJuIHRleHQ7XG5cbiAgICBpZiAoaXNOb3RCbGFuayB8fCBoYXNFeHBhbnNpb25TaWJsaW5nKSB7XG4gICAgICAvLyBQcm9jZXNzIHRoZSB3aGl0ZXNwYWNlIGluIHRoZSB0b2tlbnMgb2YgdGhpcyBUZXh0IG5vZGVcbiAgICAgIGNvbnN0IHRva2VucyA9IHRleHQudG9rZW5zLm1hcCgodG9rZW4pID0+XG4gICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5URVhUID8gY3JlYXRlV2hpdGVzcGFjZVByb2Nlc3NlZFRleHRUb2tlbih0b2tlbikgOiB0b2tlbixcbiAgICAgICk7XG5cbiAgICAgIC8vIEZ1bGx5IHRyaW0gbWVzc2FnZSB3aGVuIHNpZ25pZmljYW50IHdoaXRlc3BhY2UgaXMgbm90IHByZXNlcnZlZC5cbiAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZVNpZ25pZmljYW50V2hpdGVzcGFjZSAmJiB0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgdG9rZW4gc2hvdWxkIG9ubHkgY2FsbCBgLnRyaW1TdGFydCgpYCBhbmQgdGhlIGxhc3QgdG9rZW5cbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgY2FsbCBgLnRyaW1FbmQoKWAsIGJ1dCB0aGVyZSBtaWdodCBiZSBvbmx5IG9uZSB0b2tlbiB3aGljaFxuICAgICAgICAvLyBuZWVkcyB0byBjYWxsIGJvdGguXG4gICAgICAgIGNvbnN0IGZpcnN0VG9rZW4gPSB0b2tlbnNbMF0hO1xuICAgICAgICB0b2tlbnMuc3BsaWNlKDAsIDEsIHRyaW1MZWFkaW5nV2hpdGVzcGFjZShmaXJzdFRva2VuLCBjb250ZXh0KSk7XG5cbiAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTsgLy8gQ291bGQgYmUgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IHRva2VuLlxuICAgICAgICB0b2tlbnMuc3BsaWNlKHRva2Vucy5sZW5ndGggLSAxLCAxLCB0cmltVHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RUb2tlbiwgY29udGV4dCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBQcm9jZXNzIHRoZSB3aGl0ZXNwYWNlIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIFRleHQgbm9kZS4gQWxzbyB0cmltIHRoZSBsZWFkaW5nL3RyYWlsaW5nXG4gICAgICAvLyB3aGl0ZXNwYWNlIHdoZW4gd2UgZG9uJ3QgbmVlZCB0byBwcmVzZXJ2ZSBzaWduaWZpY2FudCB3aGl0ZXNwYWNlLlxuICAgICAgY29uc3QgcHJvY2Vzc2VkID0gcHJvY2Vzc1doaXRlc3BhY2UodGV4dC52YWx1ZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucHJlc2VydmVTaWduaWZpY2FudFdoaXRlc3BhY2VcbiAgICAgICAgPyBwcm9jZXNzZWRcbiAgICAgICAgOiB0cmltTGVhZGluZ0FuZFRyYWlsaW5nV2hpdGVzcGFjZShwcm9jZXNzZWQsIGNvbnRleHQpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IGh0bWwuVGV4dCh2YWx1ZSwgdGV4dC5zb3VyY2VTcGFuLCB0b2tlbnMsIHRleHQuaTE4bik7XG4gICAgICB0aGlzLm9yaWdpbmFsTm9kZU1hcD8uc2V0KHJlc3VsdCwgdGV4dCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmlzaXRDb21tZW50KGNvbW1lbnQ6IGh0bWwuQ29tbWVudCwgY29udGV4dDogYW55KTogYW55IHtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIHZpc2l0RXhwYW5zaW9uKGV4cGFuc2lvbjogaHRtbC5FeHBhbnNpb24sIGNvbnRleHQ6IGFueSk6IGFueSB7XG4gICAgdGhpcy5pY3VFeHBhbnNpb25EZXB0aCsrO1xuICAgIGxldCBuZXdFeHBhbnNpb246IGh0bWwuRXhwYW5zaW9uO1xuICAgIHRyeSB7XG4gICAgICBuZXdFeHBhbnNpb24gPSBuZXcgaHRtbC5FeHBhbnNpb24oXG4gICAgICAgIGV4cGFuc2lvbi5zd2l0Y2hWYWx1ZSxcbiAgICAgICAgZXhwYW5zaW9uLnR5cGUsXG4gICAgICAgIHZpc2l0QWxsV2l0aFNpYmxpbmdzKHRoaXMsIGV4cGFuc2lvbi5jYXNlcyksXG4gICAgICAgIGV4cGFuc2lvbi5zb3VyY2VTcGFuLFxuICAgICAgICBleHBhbnNpb24uc3dpdGNoVmFsdWVTb3VyY2VTcGFuLFxuICAgICAgICBleHBhbnNpb24uaTE4bixcbiAgICAgICk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaWN1RXhwYW5zaW9uRGVwdGgtLTtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdpbmFsTm9kZU1hcD8uc2V0KG5ld0V4cGFuc2lvbiwgZXhwYW5zaW9uKTtcblxuICAgIHJldHVybiBuZXdFeHBhbnNpb247XG4gIH1cblxuICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZTogaHRtbC5FeHBhbnNpb25DYXNlLCBjb250ZXh0OiBhbnkpOiBhbnkge1xuICAgIGNvbnN0IG5ld0V4cGFuc2lvbkNhc2UgPSBuZXcgaHRtbC5FeHBhbnNpb25DYXNlKFxuICAgICAgZXhwYW5zaW9uQ2FzZS52YWx1ZSxcbiAgICAgIHZpc2l0QWxsV2l0aFNpYmxpbmdzKHRoaXMsIGV4cGFuc2lvbkNhc2UuZXhwcmVzc2lvbiksXG4gICAgICBleHBhbnNpb25DYXNlLnNvdXJjZVNwYW4sXG4gICAgICBleHBhbnNpb25DYXNlLnZhbHVlU291cmNlU3BhbixcbiAgICAgIGV4cGFuc2lvbkNhc2UuZXhwU291cmNlU3BhbixcbiAgICApO1xuICAgIHRoaXMub3JpZ2luYWxOb2RlTWFwPy5zZXQobmV3RXhwYW5zaW9uQ2FzZSwgZXhwYW5zaW9uQ2FzZSk7XG4gICAgcmV0dXJuIG5ld0V4cGFuc2lvbkNhc2U7XG4gIH1cblxuICB2aXNpdEJsb2NrKGJsb2NrOiBodG1sLkJsb2NrLCBjb250ZXh0OiBhbnkpOiBhbnkge1xuICAgIGNvbnN0IG5ld0Jsb2NrID0gbmV3IGh0bWwuQmxvY2soXG4gICAgICBibG9jay5uYW1lLFxuICAgICAgYmxvY2sucGFyYW1ldGVycyxcbiAgICAgIHZpc2l0QWxsV2l0aFNpYmxpbmdzKHRoaXMsIGJsb2NrLmNoaWxkcmVuKSxcbiAgICAgIGJsb2NrLnNvdXJjZVNwYW4sXG4gICAgICBibG9jay5uYW1lU3BhbixcbiAgICAgIGJsb2NrLnN0YXJ0U291cmNlU3BhbixcbiAgICAgIGJsb2NrLmVuZFNvdXJjZVNwYW4sXG4gICAgKTtcbiAgICB0aGlzLm9yaWdpbmFsTm9kZU1hcD8uc2V0KG5ld0Jsb2NrLCBibG9jayk7XG4gICAgcmV0dXJuIG5ld0Jsb2NrO1xuICB9XG5cbiAgdmlzaXRCbG9ja1BhcmFtZXRlcihwYXJhbWV0ZXI6IGh0bWwuQmxvY2tQYXJhbWV0ZXIsIGNvbnRleHQ6IGFueSkge1xuICAgIHJldHVybiBwYXJhbWV0ZXI7XG4gIH1cblxuICB2aXNpdExldERlY2xhcmF0aW9uKGRlY2w6IGh0bWwuTGV0RGVjbGFyYXRpb24sIGNvbnRleHQ6IGFueSkge1xuICAgIHJldHVybiBkZWNsO1xuICB9XG5cbiAgdmlzaXQoX25vZGU6IGh0bWwuTm9kZSwgY29udGV4dDogYW55KSB7XG4gICAgLy8gYHZpc2l0QWxsV2l0aFNpYmxpbmdzYCBwcm92aWRlcyBjb250ZXh0IG5lY2Vzc2FyeSBmb3IgSUNVIG1lc3NhZ2VzIHRvIGJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICAgIC8vIFByZWZlciB0aGF0IG92ZXIgY2FsbGluZyBgaHRtbC52aXNpdEFsbGAgZGlyZWN0bHkgb24gdGhpcyB2aXNpdG9yLlxuICAgIGlmICh0aGlzLnJlcXVpcmVDb250ZXh0ICYmICFjb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBXaGl0ZXNwYWNlVmlzaXRvciByZXF1aXJlcyBjb250ZXh0LiBWaXNpdCB2aWEgXFxgdmlzaXRBbGxXaXRoU2libGluZ3NcXGAgdG8gZ2V0IHRoaXMgY29udGV4dC5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpbUxlYWRpbmdXaGl0ZXNwYWNlKFxuICB0b2tlbjogSW50ZXJwb2xhdGVkVGV4dFRva2VuLFxuICBjb250ZXh0OiBTaWJsaW5nVmlzaXRvckNvbnRleHQgfCBudWxsLFxuKTogSW50ZXJwb2xhdGVkVGV4dFRva2VuIHtcbiAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuVHlwZS5URVhUKSByZXR1cm4gdG9rZW47XG5cbiAgY29uc3QgaXNGaXJzdFRva2VuSW5UYWcgPSAhY29udGV4dD8ucHJldjtcbiAgaWYgKCFpc0ZpcnN0VG9rZW5JblRhZykgcmV0dXJuIHRva2VuO1xuXG4gIHJldHVybiB0cmFuc2Zvcm1UZXh0VG9rZW4odG9rZW4sICh0ZXh0KSA9PiB0ZXh0LnRyaW1TdGFydCgpKTtcbn1cblxuZnVuY3Rpb24gdHJpbVRyYWlsaW5nV2hpdGVzcGFjZShcbiAgdG9rZW46IEludGVycG9sYXRlZFRleHRUb2tlbixcbiAgY29udGV4dDogU2libGluZ1Zpc2l0b3JDb250ZXh0IHwgbnVsbCxcbik6IEludGVycG9sYXRlZFRleHRUb2tlbiB7XG4gIGlmICh0b2tlbi50eXBlICE9PSBUb2tlblR5cGUuVEVYVCkgcmV0dXJuIHRva2VuO1xuXG4gIGNvbnN0IGlzTGFzdFRva2VuSW5UYWcgPSAhY29udGV4dD8ubmV4dDtcbiAgaWYgKCFpc0xhc3RUb2tlbkluVGFnKSByZXR1cm4gdG9rZW47XG5cbiAgcmV0dXJuIHRyYW5zZm9ybVRleHRUb2tlbih0b2tlbiwgKHRleHQpID0+IHRleHQudHJpbUVuZCgpKTtcbn1cblxuZnVuY3Rpb24gdHJpbUxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2UoXG4gIHRleHQ6IHN0cmluZyxcbiAgY29udGV4dDogU2libGluZ1Zpc2l0b3JDb250ZXh0IHwgbnVsbCxcbik6IHN0cmluZyB7XG4gIGNvbnN0IGlzRmlyc3RUb2tlbkluVGFnID0gIWNvbnRleHQ/LnByZXY7XG4gIGNvbnN0IGlzTGFzdFRva2VuSW5UYWcgPSAhY29udGV4dD8ubmV4dDtcblxuICBjb25zdCBtYXliZVRyaW1tZWRTdGFydCA9IGlzRmlyc3RUb2tlbkluVGFnID8gdGV4dC50cmltU3RhcnQoKSA6IHRleHQ7XG4gIGNvbnN0IG1heWJlVHJpbW1lZCA9IGlzTGFzdFRva2VuSW5UYWcgPyBtYXliZVRyaW1tZWRTdGFydC50cmltRW5kKCkgOiBtYXliZVRyaW1tZWRTdGFydDtcbiAgcmV0dXJuIG1heWJlVHJpbW1lZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV2hpdGVzcGFjZVByb2Nlc3NlZFRleHRUb2tlbih7dHlwZSwgcGFydHMsIHNvdXJjZVNwYW59OiBUZXh0VG9rZW4pOiBUZXh0VG9rZW4ge1xuICByZXR1cm4ge3R5cGUsIHBhcnRzOiBbcHJvY2Vzc1doaXRlc3BhY2UocGFydHNbMF0pXSwgc291cmNlU3Bhbn07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVRleHRUb2tlbihcbiAge3R5cGUsIHBhcnRzLCBzb3VyY2VTcGFufTogVGV4dFRva2VuLFxuICB0cmFuc2Zvcm06IChwYXJ0czogc3RyaW5nKSA9PiBzdHJpbmcsXG4pOiBUZXh0VG9rZW4ge1xuICAvLyBgVGV4dFRva2VuYCBvbmx5IGV2ZXIgaGFzIG9uZSBwYXJ0IGFzIGRlZmluZWQgaW4gaXRzIHR5cGUsIHNvIHdlIGp1c3QgdHJhbnNmb3JtIHRoZSBmaXJzdCBlbGVtZW50LlxuICByZXR1cm4ge3R5cGUsIHBhcnRzOiBbdHJhbnNmb3JtKHBhcnRzWzBdKV0sIHNvdXJjZVNwYW59O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzV2hpdGVzcGFjZSh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcmVwbGFjZU5nc3AodGV4dCkucmVwbGFjZShXU19SRVBMQUNFX1JFR0VYUCwgJyAnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVdoaXRlc3BhY2VzKFxuICBodG1sQXN0V2l0aEVycm9yczogUGFyc2VUcmVlUmVzdWx0LFxuICBwcmVzZXJ2ZVNpZ25pZmljYW50V2hpdGVzcGFjZTogYm9vbGVhbixcbik6IFBhcnNlVHJlZVJlc3VsdCB7XG4gIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KFxuICAgIHZpc2l0QWxsV2l0aFNpYmxpbmdzKFxuICAgICAgbmV3IFdoaXRlc3BhY2VWaXNpdG9yKHByZXNlcnZlU2lnbmlmaWNhbnRXaGl0ZXNwYWNlKSxcbiAgICAgIGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2RlcyxcbiAgICApLFxuICAgIGh0bWxBc3RXaXRoRXJyb3JzLmVycm9ycyxcbiAgKTtcbn1cblxuaW50ZXJmYWNlIFNpYmxpbmdWaXNpdG9yQ29udGV4dCB7XG4gIHByZXY6IGh0bWwuTm9kZSB8IHVuZGVmaW5lZDtcbiAgbmV4dDogaHRtbC5Ob2RlIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlzaXRBbGxXaXRoU2libGluZ3ModmlzaXRvcjogV2hpdGVzcGFjZVZpc2l0b3IsIG5vZGVzOiBodG1sLk5vZGVbXSk6IGFueVtdIHtcbiAgY29uc3QgcmVzdWx0OiBhbnlbXSA9IFtdO1xuXG4gIG5vZGVzLmZvckVhY2goKGFzdCwgaSkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQ6IFNpYmxpbmdWaXNpdG9yQ29udGV4dCA9IHtwcmV2OiBub2Rlc1tpIC0gMV0sIG5leHQ6IG5vZGVzW2kgKyAxXX07XG4gICAgY29uc3QgYXN0UmVzdWx0ID0gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIGlmIChhc3RSZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFzdFJlc3VsdCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdfQ==