/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as o from '../output/output_ast';
import { Identifiers as R3 } from './r3_identifiers';
import { devOnlyGuardedExpression } from './util';
export function compileClassMetadata(metadata) {
    // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its
    // metadata.
    const fnCall = o.importExpr(R3.setClassMetadata).callFn([
        metadata.type,
        metadata.decorators,
        metadata.ctorParameters ?? o.literal(null),
        metadata.propDecorators ?? o.literal(null),
    ]);
    const iife = o.arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]);
    return iife.callFn([]);
}
/**
 * Wraps the `setClassMetadata` function with extra logic that dynamically
 * loads dependencies from `@defer` blocks.
 *
 * Generates a call like this:
 * ```
 * setClassMetadataAsync(type, () => [
 *   import('./cmp-a').then(m => m.CmpA);
 *   import('./cmp-b').then(m => m.CmpB);
 * ], (CmpA, CmpB) => {
 *   setClassMetadata(type, decorators, ctorParameters, propParameters);
 * });
 * ```
 *
 * Similar to the `setClassMetadata` call, it's wrapped into the `ngDevMode`
 * check to tree-shake away this code in production mode.
 */
export function compileComponentClassMetadata(metadata, deferrableTypes) {
    if (deferrableTypes === null || deferrableTypes.length === 0) {
        // If there are no deferrable symbols - just generate a regular `setClassMetadata` call.
        return compileClassMetadata(metadata);
    }
    const dynamicImports = [];
    const importedSymbols = [];
    for (const { symbolName, importPath, isDefaultImport } of deferrableTypes) {
        // e.g. `(m) => m.CmpA`
        const innerFn = 
        // Default imports are always accessed through the `default` property.
        o.arrowFn([new o.FnParam('m', o.DYNAMIC_TYPE)], o.variable('m').prop(isDefaultImport ? 'default' : symbolName));
        // e.g. `import('./cmp-a').then(...)`
        const importExpr = (new o.DynamicImportExpr(importPath)).prop('then').callFn([innerFn]);
        dynamicImports.push(importExpr);
        importedSymbols.push(new o.FnParam(symbolName, o.DYNAMIC_TYPE));
    }
    // e.g. `() => [ ... ];`
    const dependencyLoadingFn = o.arrowFn([], o.literalArr(dynamicImports));
    // e.g. `setClassMetadata(...)`
    const setClassMetadataCall = o.importExpr(R3.setClassMetadata).callFn([
        metadata.type,
        metadata.decorators,
        metadata.ctorParameters ?? o.literal(null),
        metadata.propDecorators ?? o.literal(null),
    ]);
    // e.g. `(CmpA) => setClassMetadata(...)`
    const setClassMetaWrapper = o.arrowFn(importedSymbols, [setClassMetadataCall.toStmt()]);
    // Final `setClassMetadataAsync()` call with all arguments
    const setClassMetaAsync = o.importExpr(R3.setClassMetadataAsync).callFn([
        metadata.type, dependencyLoadingFn, setClassMetaWrapper
    ]);
    // Generate an ngDevMode guarded call to `setClassMetadataAsync` with
    // the class identifier and its metadata, so that this call can be tree-shaken.
    const iife = o.arrowFn([], [devOnlyGuardedExpression(setClassMetaAsync).toStmt()]);
    return iife.callFn([]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicjNfY2xhc3NfbWV0YWRhdGFfY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci9zcmMvcmVuZGVyMy9yM19jbGFzc19tZXRhZGF0YV9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFDSCxPQUFPLEtBQUssQ0FBQyxNQUFNLHNCQUFzQixDQUFDO0FBRTFDLE9BQU8sRUFBQyxXQUFXLElBQUksRUFBRSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDbkQsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sUUFBUSxDQUFDO0FBa0NoRCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsUUFBeUI7SUFDNUQsMkZBQTJGO0lBQzNGLFlBQVk7SUFDWixNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUN0RCxRQUFRLENBQUMsSUFBSTtRQUNiLFFBQVEsQ0FBQyxVQUFVO1FBQ25CLFFBQVEsQ0FBQyxjQUFjLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDMUMsUUFBUSxDQUFDLGNBQWMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztLQUMzQyxDQUFDLENBQUM7SUFDSCxNQUFNLElBQUksR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekIsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTSxVQUFVLDZCQUE2QixDQUN6QyxRQUF5QixFQUN6QixlQUFxRDtJQUN2RCxJQUFJLGVBQWUsS0FBSyxJQUFJLElBQUksZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUM3RCx3RkFBd0Y7UUFDeEYsT0FBTyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsTUFBTSxjQUFjLEdBQW1CLEVBQUUsQ0FBQztJQUMxQyxNQUFNLGVBQWUsR0FBZ0IsRUFBRSxDQUFDO0lBQ3hDLEtBQUssTUFBTSxFQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFDLElBQUksZUFBZSxFQUFFLENBQUM7UUFDeEUsdUJBQXVCO1FBQ3ZCLE1BQU0sT0FBTztRQUNULHNFQUFzRTtRQUN0RSxDQUFDLENBQUMsT0FBTyxDQUNMLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsRUFDcEMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFFeEUscUNBQXFDO1FBQ3JDLE1BQU0sVUFBVSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUV4RixjQUFjLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2hDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQsd0JBQXdCO0lBQ3hCLE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO0lBRXhFLCtCQUErQjtJQUMvQixNQUFNLG9CQUFvQixHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3BFLFFBQVEsQ0FBQyxJQUFJO1FBQ2IsUUFBUSxDQUFDLFVBQVU7UUFDbkIsUUFBUSxDQUFDLGNBQWMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUMxQyxRQUFRLENBQUMsY0FBYyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO0tBQzNDLENBQUMsQ0FBQztJQUVILHlDQUF5QztJQUN6QyxNQUFNLG1CQUFtQixHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUMsb0JBQW9CLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBRXhGLDBEQUEwRDtJQUMxRCxNQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLHFCQUFxQixDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3RFLFFBQVEsQ0FBQyxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsbUJBQW1CO0tBQ3hELENBQUMsQ0FBQztJQUVILHFFQUFxRTtJQUNyRSwrRUFBK0U7SUFDL0UsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuRixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0ICogYXMgbyBmcm9tICcuLi9vdXRwdXQvb3V0cHV0X2FzdCc7XG5cbmltcG9ydCB7SWRlbnRpZmllcnMgYXMgUjN9IGZyb20gJy4vcjNfaWRlbnRpZmllcnMnO1xuaW1wb3J0IHtkZXZPbmx5R3VhcmRlZEV4cHJlc3Npb259IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge1IzRGVmZXJQZXJDb21wb25lbnREZXBlbmRlbmN5fSBmcm9tICcuL3ZpZXcvYXBpJztcblxuZXhwb3J0IHR5cGUgQ29tcGlsZUNsYXNzTWV0YWRhdGFGbiA9IChtZXRhZGF0YTogUjNDbGFzc01ldGFkYXRhKSA9PiBvLkV4cHJlc3Npb247XG5cbi8qKlxuICogTWV0YWRhdGEgb2YgYSBjbGFzcyB3aGljaCBjYXB0dXJlcyB0aGUgb3JpZ2luYWwgQW5ndWxhciBkZWNvcmF0b3JzIG9mIGEgY2xhc3MuIFRoZSBvcmlnaW5hbFxuICogZGVjb3JhdG9ycyBhcmUgcHJlc2VydmVkIGluIHRoZSBnZW5lcmF0ZWQgY29kZSB0byBhbGxvdyBUZXN0QmVkIEFQSXMgdG8gcmVjb21waWxlIHRoZSBjbGFzc1xuICogdXNpbmcgdGhlIG9yaWdpbmFsIGRlY29yYXRvciB3aXRoIGEgc2V0IG9mIG92ZXJyaWRlcyBhcHBsaWVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFIzQ2xhc3NNZXRhZGF0YSB7XG4gIC8qKlxuICAgKiBUaGUgY2xhc3MgdHlwZSBmb3Igd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGNhcHR1cmVkLlxuICAgKi9cbiAgdHlwZTogby5FeHByZXNzaW9uO1xuXG4gIC8qKlxuICAgKiBBbiBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgQW5ndWxhciBkZWNvcmF0b3JzIHRoYXQgd2VyZSBhcHBsaWVkIG9uIHRoZSBjbGFzcy5cbiAgICovXG4gIGRlY29yYXRvcnM6IG8uRXhwcmVzc2lvbjtcblxuICAvKipcbiAgICogQW4gZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIEFuZ3VsYXIgZGVjb3JhdG9ycyBhcHBsaWVkIHRvIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMsIG9yIGBudWxsYFxuICAgKiBpZiB0aGVyZSBpcyBubyBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGN0b3JQYXJhbWV0ZXJzOiBvLkV4cHJlc3Npb258bnVsbDtcblxuICAvKipcbiAgICogQW4gZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIEFuZ3VsYXIgZGVjb3JhdG9ycyB0aGF0IHdlcmUgYXBwbGllZCBvbiB0aGUgcHJvcGVydGllcyBvZiB0aGVcbiAgICogY2xhc3MsIG9yIGBudWxsYCBpZiBubyBwcm9wZXJ0aWVzIGhhdmUgZGVjb3JhdG9ycy5cbiAgICovXG4gIHByb3BEZWNvcmF0b3JzOiBvLkV4cHJlc3Npb258bnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVDbGFzc01ldGFkYXRhKG1ldGFkYXRhOiBSM0NsYXNzTWV0YWRhdGEpOiBvLkV4cHJlc3Npb24ge1xuICAvLyBHZW5lcmF0ZSBhbiBuZ0Rldk1vZGUgZ3VhcmRlZCBjYWxsIHRvIHNldENsYXNzTWV0YWRhdGEgd2l0aCB0aGUgY2xhc3MgaWRlbnRpZmllciBhbmQgaXRzXG4gIC8vIG1ldGFkYXRhLlxuICBjb25zdCBmbkNhbGwgPSBvLmltcG9ydEV4cHIoUjMuc2V0Q2xhc3NNZXRhZGF0YSkuY2FsbEZuKFtcbiAgICBtZXRhZGF0YS50eXBlLFxuICAgIG1ldGFkYXRhLmRlY29yYXRvcnMsXG4gICAgbWV0YWRhdGEuY3RvclBhcmFtZXRlcnMgPz8gby5saXRlcmFsKG51bGwpLFxuICAgIG1ldGFkYXRhLnByb3BEZWNvcmF0b3JzID8/IG8ubGl0ZXJhbChudWxsKSxcbiAgXSk7XG4gIGNvbnN0IGlpZmUgPSBvLmFycm93Rm4oW10sIFtkZXZPbmx5R3VhcmRlZEV4cHJlc3Npb24oZm5DYWxsKS50b1N0bXQoKV0pO1xuICByZXR1cm4gaWlmZS5jYWxsRm4oW10pO1xufVxuXG4vKipcbiAqIFdyYXBzIHRoZSBgc2V0Q2xhc3NNZXRhZGF0YWAgZnVuY3Rpb24gd2l0aCBleHRyYSBsb2dpYyB0aGF0IGR5bmFtaWNhbGx5XG4gKiBsb2FkcyBkZXBlbmRlbmNpZXMgZnJvbSBgQGRlZmVyYCBibG9ja3MuXG4gKlxuICogR2VuZXJhdGVzIGEgY2FsbCBsaWtlIHRoaXM6XG4gKiBgYGBcbiAqIHNldENsYXNzTWV0YWRhdGFBc3luYyh0eXBlLCAoKSA9PiBbXG4gKiAgIGltcG9ydCgnLi9jbXAtYScpLnRoZW4obSA9PiBtLkNtcEEpO1xuICogICBpbXBvcnQoJy4vY21wLWInKS50aGVuKG0gPT4gbS5DbXBCKTtcbiAqIF0sIChDbXBBLCBDbXBCKSA9PiB7XG4gKiAgIHNldENsYXNzTWV0YWRhdGEodHlwZSwgZGVjb3JhdG9ycywgY3RvclBhcmFtZXRlcnMsIHByb3BQYXJhbWV0ZXJzKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogU2ltaWxhciB0byB0aGUgYHNldENsYXNzTWV0YWRhdGFgIGNhbGwsIGl0J3Mgd3JhcHBlZCBpbnRvIHRoZSBgbmdEZXZNb2RlYFxuICogY2hlY2sgdG8gdHJlZS1zaGFrZSBhd2F5IHRoaXMgY29kZSBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlQ29tcG9uZW50Q2xhc3NNZXRhZGF0YShcbiAgICBtZXRhZGF0YTogUjNDbGFzc01ldGFkYXRhLFxuICAgIGRlZmVycmFibGVUeXBlczogUjNEZWZlclBlckNvbXBvbmVudERlcGVuZGVuY3lbXXxudWxsKTogby5FeHByZXNzaW9uIHtcbiAgaWYgKGRlZmVycmFibGVUeXBlcyA9PT0gbnVsbCB8fCBkZWZlcnJhYmxlVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlZmVycmFibGUgc3ltYm9scyAtIGp1c3QgZ2VuZXJhdGUgYSByZWd1bGFyIGBzZXRDbGFzc01ldGFkYXRhYCBjYWxsLlxuICAgIHJldHVybiBjb21waWxlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YSk7XG4gIH1cblxuICBjb25zdCBkeW5hbWljSW1wb3J0czogby5FeHByZXNzaW9uW10gPSBbXTtcbiAgY29uc3QgaW1wb3J0ZWRTeW1ib2xzOiBvLkZuUGFyYW1bXSA9IFtdO1xuICBmb3IgKGNvbnN0IHtzeW1ib2xOYW1lLCBpbXBvcnRQYXRoLCBpc0RlZmF1bHRJbXBvcnR9IG9mIGRlZmVycmFibGVUeXBlcykge1xuICAgIC8vIGUuZy4gYChtKSA9PiBtLkNtcEFgXG4gICAgY29uc3QgaW5uZXJGbiA9XG4gICAgICAgIC8vIERlZmF1bHQgaW1wb3J0cyBhcmUgYWx3YXlzIGFjY2Vzc2VkIHRocm91Z2ggdGhlIGBkZWZhdWx0YCBwcm9wZXJ0eS5cbiAgICAgICAgby5hcnJvd0ZuKFxuICAgICAgICAgICAgW25ldyBvLkZuUGFyYW0oJ20nLCBvLkRZTkFNSUNfVFlQRSldLFxuICAgICAgICAgICAgby52YXJpYWJsZSgnbScpLnByb3AoaXNEZWZhdWx0SW1wb3J0ID8gJ2RlZmF1bHQnIDogc3ltYm9sTmFtZSkpO1xuXG4gICAgLy8gZS5nLiBgaW1wb3J0KCcuL2NtcC1hJykudGhlbiguLi4pYFxuICAgIGNvbnN0IGltcG9ydEV4cHIgPSAobmV3IG8uRHluYW1pY0ltcG9ydEV4cHIoaW1wb3J0UGF0aCkpLnByb3AoJ3RoZW4nKS5jYWxsRm4oW2lubmVyRm5dKTtcblxuICAgIGR5bmFtaWNJbXBvcnRzLnB1c2goaW1wb3J0RXhwcik7XG4gICAgaW1wb3J0ZWRTeW1ib2xzLnB1c2gobmV3IG8uRm5QYXJhbShzeW1ib2xOYW1lLCBvLkRZTkFNSUNfVFlQRSkpO1xuICB9XG5cbiAgLy8gZS5nLiBgKCkgPT4gWyAuLi4gXTtgXG4gIGNvbnN0IGRlcGVuZGVuY3lMb2FkaW5nRm4gPSBvLmFycm93Rm4oW10sIG8ubGl0ZXJhbEFycihkeW5hbWljSW1wb3J0cykpO1xuXG4gIC8vIGUuZy4gYHNldENsYXNzTWV0YWRhdGEoLi4uKWBcbiAgY29uc3Qgc2V0Q2xhc3NNZXRhZGF0YUNhbGwgPSBvLmltcG9ydEV4cHIoUjMuc2V0Q2xhc3NNZXRhZGF0YSkuY2FsbEZuKFtcbiAgICBtZXRhZGF0YS50eXBlLFxuICAgIG1ldGFkYXRhLmRlY29yYXRvcnMsXG4gICAgbWV0YWRhdGEuY3RvclBhcmFtZXRlcnMgPz8gby5saXRlcmFsKG51bGwpLFxuICAgIG1ldGFkYXRhLnByb3BEZWNvcmF0b3JzID8/IG8ubGl0ZXJhbChudWxsKSxcbiAgXSk7XG5cbiAgLy8gZS5nLiBgKENtcEEpID0+IHNldENsYXNzTWV0YWRhdGEoLi4uKWBcbiAgY29uc3Qgc2V0Q2xhc3NNZXRhV3JhcHBlciA9IG8uYXJyb3dGbihpbXBvcnRlZFN5bWJvbHMsIFtzZXRDbGFzc01ldGFkYXRhQ2FsbC50b1N0bXQoKV0pO1xuXG4gIC8vIEZpbmFsIGBzZXRDbGFzc01ldGFkYXRhQXN5bmMoKWAgY2FsbCB3aXRoIGFsbCBhcmd1bWVudHNcbiAgY29uc3Qgc2V0Q2xhc3NNZXRhQXN5bmMgPSBvLmltcG9ydEV4cHIoUjMuc2V0Q2xhc3NNZXRhZGF0YUFzeW5jKS5jYWxsRm4oW1xuICAgIG1ldGFkYXRhLnR5cGUsIGRlcGVuZGVuY3lMb2FkaW5nRm4sIHNldENsYXNzTWV0YVdyYXBwZXJcbiAgXSk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gbmdEZXZNb2RlIGd1YXJkZWQgY2FsbCB0byBgc2V0Q2xhc3NNZXRhZGF0YUFzeW5jYCB3aXRoXG4gIC8vIHRoZSBjbGFzcyBpZGVudGlmaWVyIGFuZCBpdHMgbWV0YWRhdGEsIHNvIHRoYXQgdGhpcyBjYWxsIGNhbiBiZSB0cmVlLXNoYWtlbi5cbiAgY29uc3QgaWlmZSA9IG8uYXJyb3dGbihbXSwgW2Rldk9ubHlHdWFyZGVkRXhwcmVzc2lvbihzZXRDbGFzc01ldGFBc3luYykudG9TdG10KCldKTtcbiAgcmV0dXJuIGlpZmUuY2FsbEZuKFtdKTtcbn1cbiJdfQ==