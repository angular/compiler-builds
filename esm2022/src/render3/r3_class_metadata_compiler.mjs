/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as o from '../output/output_ast';
import { Identifiers as R3 } from './r3_identifiers';
import { devOnlyGuardedExpression } from './util';
export function compileClassMetadata(metadata) {
    const fnCall = internalCompileClassMetadata(metadata);
    return o.arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]).callFn([]);
}
/** Compiles only the `setClassMetadata` call without any additional wrappers. */
function internalCompileClassMetadata(metadata) {
    return o.importExpr(R3.setClassMetadata).callFn([
        metadata.type,
        metadata.decorators,
        metadata.ctorParameters ?? o.literal(null),
        metadata.propDecorators ?? o.literal(null),
    ]);
}
/**
 * Wraps the `setClassMetadata` function with extra logic that dynamically
 * loads dependencies from `@defer` blocks.
 *
 * Generates a call like this:
 * ```
 * setClassMetadataAsync(type, () => [
 *   import('./cmp-a').then(m => m.CmpA);
 *   import('./cmp-b').then(m => m.CmpB);
 * ], (CmpA, CmpB) => {
 *   setClassMetadata(type, decorators, ctorParameters, propParameters);
 * });
 * ```
 *
 * Similar to the `setClassMetadata` call, it's wrapped into the `ngDevMode`
 * check to tree-shake away this code in production mode.
 */
export function compileComponentClassMetadata(metadata, dependencies) {
    if (dependencies === null || dependencies.length === 0) {
        // If there are no deferrable symbols - just generate a regular `setClassMetadata` call.
        return compileClassMetadata(metadata);
    }
    return internalCompileSetClassMetadataAsync(metadata, dependencies.map(dep => new o.FnParam(dep.symbolName, o.DYNAMIC_TYPE)), compileComponentMetadataAsyncResolver(dependencies));
}
/**
 * Identical to `compileComponentClassMetadata`. Used for the cases where we're unable to
 * analyze the deferred block dependencies, but we have a reference to the compiled
 * dependency resolver function that we can use as is.
 * @param metadata Class metadata for the internal `setClassMetadata` call.
 * @param deferResolver Expression representing the deferred dependency loading function.
 * @param deferredDependencyNames Names of the dependencies that are being loaded asynchronously.
 */
export function compileOpaqueAsyncClassMetadata(metadata, deferResolver, deferredDependencyNames) {
    return internalCompileSetClassMetadataAsync(metadata, deferredDependencyNames.map(name => new o.FnParam(name, o.DYNAMIC_TYPE)), deferResolver);
}
/**
 * Internal logic used to compile a `setClassMetadataAsync` call.
 * @param metadata Class metadata for the internal `setClassMetadata` call.
 * @param wrapperParams Parameters to be set on the callback that wraps `setClassMetata`.
 * @param dependencyResolverFn Function to resolve the deferred dependencies.
 */
function internalCompileSetClassMetadataAsync(metadata, wrapperParams, dependencyResolverFn) {
    // Omit the wrapper since it'll be added around `setClassMetadataAsync` instead.
    const setClassMetadataCall = internalCompileClassMetadata(metadata);
    const setClassMetaWrapper = o.arrowFn(wrapperParams, [setClassMetadataCall.toStmt()]);
    const setClassMetaAsync = o.importExpr(R3.setClassMetadataAsync).callFn([
        metadata.type, dependencyResolverFn, setClassMetaWrapper
    ]);
    return o.arrowFn([], [devOnlyGuardedExpression(setClassMetaAsync).toStmt()]).callFn([]);
}
/**
 * Compiles the function that loads the dependencies for the
 * entire component in `setClassMetadataAsync`.
 */
export function compileComponentMetadataAsyncResolver(dependencies) {
    const dynamicImports = dependencies.map(({ symbolName, importPath, isDefaultImport }) => {
        // e.g. `(m) => m.CmpA`
        const innerFn = 
        // Default imports are always accessed through the `default` property.
        o.arrowFn([new o.FnParam('m', o.DYNAMIC_TYPE)], o.variable('m').prop(isDefaultImport ? 'default' : symbolName));
        // e.g. `import('./cmp-a').then(...)`
        return new o.DynamicImportExpr(importPath).prop('then').callFn([innerFn]);
    });
    // e.g. `() => [ ... ];`
    return o.arrowFn([], o.literalArr(dynamicImports));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicjNfY2xhc3NfbWV0YWRhdGFfY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci9zcmMvcmVuZGVyMy9yM19jbGFzc19tZXRhZGF0YV9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFDSCxPQUFPLEtBQUssQ0FBQyxNQUFNLHNCQUFzQixDQUFDO0FBRTFDLE9BQU8sRUFBQyxXQUFXLElBQUksRUFBRSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDbkQsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sUUFBUSxDQUFDO0FBa0NoRCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsUUFBeUI7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNEJBQTRCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdEQsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDL0UsQ0FBQztBQUVELGlGQUFpRjtBQUNqRixTQUFTLDRCQUE0QixDQUFDLFFBQXlCO0lBQzdELE9BQU8sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDOUMsUUFBUSxDQUFDLElBQUk7UUFDYixRQUFRLENBQUMsVUFBVTtRQUNuQixRQUFRLENBQUMsY0FBYyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQzFDLFFBQVEsQ0FBQyxjQUFjLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7S0FDM0MsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTSxVQUFVLDZCQUE2QixDQUN6QyxRQUF5QixFQUFFLFlBQWtEO0lBQy9FLElBQUksWUFBWSxLQUFLLElBQUksSUFBSSxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ3ZELHdGQUF3RjtRQUN4RixPQUFPLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxPQUFPLG9DQUFvQyxDQUN2QyxRQUFRLEVBQUUsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUNoRixxQ0FBcUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0FBQzNELENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLCtCQUErQixDQUMzQyxRQUF5QixFQUFFLGFBQTJCLEVBQ3RELHVCQUFpQztJQUNuQyxPQUFPLG9DQUFvQyxDQUN2QyxRQUFRLEVBQUUsdUJBQXVCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsRUFDbEYsYUFBYSxDQUFDLENBQUM7QUFDckIsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxvQ0FBb0MsQ0FDekMsUUFBeUIsRUFBRSxhQUEwQixFQUNyRCxvQkFBa0M7SUFDcEMsZ0ZBQWdGO0lBQ2hGLE1BQU0sb0JBQW9CLEdBQUcsNEJBQTRCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEUsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN0RixNQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLHFCQUFxQixDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3RFLFFBQVEsQ0FBQyxJQUFJLEVBQUUsb0JBQW9CLEVBQUUsbUJBQW1CO0tBQ3pELENBQUMsQ0FBQztJQUVILE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDMUYsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxxQ0FBcUMsQ0FDakQsWUFBNkM7SUFDL0MsTUFBTSxjQUFjLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUMsRUFBRSxFQUFFO1FBQ3BGLHVCQUF1QjtRQUN2QixNQUFNLE9BQU87UUFDVCxzRUFBc0U7UUFDdEUsQ0FBQyxDQUFDLE9BQU8sQ0FDTCxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQ3BDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBRXhFLHFDQUFxQztRQUNyQyxPQUFPLElBQUksQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzVFLENBQUMsQ0FBQyxDQUFDO0lBRUgsd0JBQXdCO0lBQ3hCLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO0FBQ3JELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCAqIGFzIG8gZnJvbSAnLi4vb3V0cHV0L291dHB1dF9hc3QnO1xuXG5pbXBvcnQge0lkZW50aWZpZXJzIGFzIFIzfSBmcm9tICcuL3IzX2lkZW50aWZpZXJzJztcbmltcG9ydCB7ZGV2T25seUd1YXJkZWRFeHByZXNzaW9ufSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHtSM0RlZmVyUGVyQ29tcG9uZW50RGVwZW5kZW5jeX0gZnJvbSAnLi92aWV3L2FwaSc7XG5cbmV4cG9ydCB0eXBlIENvbXBpbGVDbGFzc01ldGFkYXRhRm4gPSAobWV0YWRhdGE6IFIzQ2xhc3NNZXRhZGF0YSkgPT4gby5FeHByZXNzaW9uO1xuXG4vKipcbiAqIE1ldGFkYXRhIG9mIGEgY2xhc3Mgd2hpY2ggY2FwdHVyZXMgdGhlIG9yaWdpbmFsIEFuZ3VsYXIgZGVjb3JhdG9ycyBvZiBhIGNsYXNzLiBUaGUgb3JpZ2luYWxcbiAqIGRlY29yYXRvcnMgYXJlIHByZXNlcnZlZCBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUgdG8gYWxsb3cgVGVzdEJlZCBBUElzIHRvIHJlY29tcGlsZSB0aGUgY2xhc3NcbiAqIHVzaW5nIHRoZSBvcmlnaW5hbCBkZWNvcmF0b3Igd2l0aCBhIHNldCBvZiBvdmVycmlkZXMgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSM0NsYXNzTWV0YWRhdGEge1xuICAvKipcbiAgICogVGhlIGNsYXNzIHR5cGUgZm9yIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBjYXB0dXJlZC5cbiAgICovXG4gIHR5cGU6IG8uRXhwcmVzc2lvbjtcblxuICAvKipcbiAgICogQW4gZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIEFuZ3VsYXIgZGVjb3JhdG9ycyB0aGF0IHdlcmUgYXBwbGllZCBvbiB0aGUgY2xhc3MuXG4gICAqL1xuICBkZWNvcmF0b3JzOiBvLkV4cHJlc3Npb247XG5cbiAgLyoqXG4gICAqIEFuIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBBbmd1bGFyIGRlY29yYXRvcnMgYXBwbGllZCB0byBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzLCBvciBgbnVsbGBcbiAgICogaWYgdGhlcmUgaXMgbm8gY29uc3RydWN0b3IuXG4gICAqL1xuICBjdG9yUGFyYW1ldGVyczogby5FeHByZXNzaW9ufG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBBbmd1bGFyIGRlY29yYXRvcnMgdGhhdCB3ZXJlIGFwcGxpZWQgb24gdGhlIHByb3BlcnRpZXMgb2YgdGhlXG4gICAqIGNsYXNzLCBvciBgbnVsbGAgaWYgbm8gcHJvcGVydGllcyBoYXZlIGRlY29yYXRvcnMuXG4gICAqL1xuICBwcm9wRGVjb3JhdG9yczogby5FeHByZXNzaW9ufG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YTogUjNDbGFzc01ldGFkYXRhKTogby5JbnZva2VGdW5jdGlvbkV4cHIge1xuICBjb25zdCBmbkNhbGwgPSBpbnRlcm5hbENvbXBpbGVDbGFzc01ldGFkYXRhKG1ldGFkYXRhKTtcbiAgcmV0dXJuIG8uYXJyb3dGbihbXSwgW2Rldk9ubHlHdWFyZGVkRXhwcmVzc2lvbihmbkNhbGwpLnRvU3RtdCgpXSkuY2FsbEZuKFtdKTtcbn1cblxuLyoqIENvbXBpbGVzIG9ubHkgdGhlIGBzZXRDbGFzc01ldGFkYXRhYCBjYWxsIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgd3JhcHBlcnMuICovXG5mdW5jdGlvbiBpbnRlcm5hbENvbXBpbGVDbGFzc01ldGFkYXRhKG1ldGFkYXRhOiBSM0NsYXNzTWV0YWRhdGEpOiBvLkludm9rZUZ1bmN0aW9uRXhwciB7XG4gIHJldHVybiBvLmltcG9ydEV4cHIoUjMuc2V0Q2xhc3NNZXRhZGF0YSkuY2FsbEZuKFtcbiAgICBtZXRhZGF0YS50eXBlLFxuICAgIG1ldGFkYXRhLmRlY29yYXRvcnMsXG4gICAgbWV0YWRhdGEuY3RvclBhcmFtZXRlcnMgPz8gby5saXRlcmFsKG51bGwpLFxuICAgIG1ldGFkYXRhLnByb3BEZWNvcmF0b3JzID8/IG8ubGl0ZXJhbChudWxsKSxcbiAgXSk7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIGBzZXRDbGFzc01ldGFkYXRhYCBmdW5jdGlvbiB3aXRoIGV4dHJhIGxvZ2ljIHRoYXQgZHluYW1pY2FsbHlcbiAqIGxvYWRzIGRlcGVuZGVuY2llcyBmcm9tIGBAZGVmZXJgIGJsb2Nrcy5cbiAqXG4gKiBHZW5lcmF0ZXMgYSBjYWxsIGxpa2UgdGhpczpcbiAqIGBgYFxuICogc2V0Q2xhc3NNZXRhZGF0YUFzeW5jKHR5cGUsICgpID0+IFtcbiAqICAgaW1wb3J0KCcuL2NtcC1hJykudGhlbihtID0+IG0uQ21wQSk7XG4gKiAgIGltcG9ydCgnLi9jbXAtYicpLnRoZW4obSA9PiBtLkNtcEIpO1xuICogXSwgKENtcEEsIENtcEIpID0+IHtcbiAqICAgc2V0Q2xhc3NNZXRhZGF0YSh0eXBlLCBkZWNvcmF0b3JzLCBjdG9yUGFyYW1ldGVycywgcHJvcFBhcmFtZXRlcnMpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSBgc2V0Q2xhc3NNZXRhZGF0YWAgY2FsbCwgaXQncyB3cmFwcGVkIGludG8gdGhlIGBuZ0Rldk1vZGVgXG4gKiBjaGVjayB0byB0cmVlLXNoYWtlIGF3YXkgdGhpcyBjb2RlIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVDb21wb25lbnRDbGFzc01ldGFkYXRhKFxuICAgIG1ldGFkYXRhOiBSM0NsYXNzTWV0YWRhdGEsIGRlcGVuZGVuY2llczogUjNEZWZlclBlckNvbXBvbmVudERlcGVuZGVuY3lbXXxudWxsKTogby5FeHByZXNzaW9uIHtcbiAgaWYgKGRlcGVuZGVuY2llcyA9PT0gbnVsbCB8fCBkZXBlbmRlbmNpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlZmVycmFibGUgc3ltYm9scyAtIGp1c3QgZ2VuZXJhdGUgYSByZWd1bGFyIGBzZXRDbGFzc01ldGFkYXRhYCBjYWxsLlxuICAgIHJldHVybiBjb21waWxlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YSk7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxDb21waWxlU2V0Q2xhc3NNZXRhZGF0YUFzeW5jKFxuICAgICAgbWV0YWRhdGEsIGRlcGVuZGVuY2llcy5tYXAoZGVwID0+IG5ldyBvLkZuUGFyYW0oZGVwLnN5bWJvbE5hbWUsIG8uRFlOQU1JQ19UWVBFKSksXG4gICAgICBjb21waWxlQ29tcG9uZW50TWV0YWRhdGFBc3luY1Jlc29sdmVyKGRlcGVuZGVuY2llcykpO1xufVxuXG4vKipcbiAqIElkZW50aWNhbCB0byBgY29tcGlsZUNvbXBvbmVudENsYXNzTWV0YWRhdGFgLiBVc2VkIGZvciB0aGUgY2FzZXMgd2hlcmUgd2UncmUgdW5hYmxlIHRvXG4gKiBhbmFseXplIHRoZSBkZWZlcnJlZCBibG9jayBkZXBlbmRlbmNpZXMsIGJ1dCB3ZSBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb21waWxlZFxuICogZGVwZW5kZW5jeSByZXNvbHZlciBmdW5jdGlvbiB0aGF0IHdlIGNhbiB1c2UgYXMgaXMuXG4gKiBAcGFyYW0gbWV0YWRhdGEgQ2xhc3MgbWV0YWRhdGEgZm9yIHRoZSBpbnRlcm5hbCBgc2V0Q2xhc3NNZXRhZGF0YWAgY2FsbC5cbiAqIEBwYXJhbSBkZWZlclJlc29sdmVyIEV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBkZWZlcnJlZCBkZXBlbmRlbmN5IGxvYWRpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0gZGVmZXJyZWREZXBlbmRlbmN5TmFtZXMgTmFtZXMgb2YgdGhlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBiZWluZyBsb2FkZWQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlT3BhcXVlQXN5bmNDbGFzc01ldGFkYXRhKFxuICAgIG1ldGFkYXRhOiBSM0NsYXNzTWV0YWRhdGEsIGRlZmVyUmVzb2x2ZXI6IG8uRXhwcmVzc2lvbixcbiAgICBkZWZlcnJlZERlcGVuZGVuY3lOYW1lczogc3RyaW5nW10pOiBvLkV4cHJlc3Npb24ge1xuICByZXR1cm4gaW50ZXJuYWxDb21waWxlU2V0Q2xhc3NNZXRhZGF0YUFzeW5jKFxuICAgICAgbWV0YWRhdGEsIGRlZmVycmVkRGVwZW5kZW5jeU5hbWVzLm1hcChuYW1lID0+IG5ldyBvLkZuUGFyYW0obmFtZSwgby5EWU5BTUlDX1RZUEUpKSxcbiAgICAgIGRlZmVyUmVzb2x2ZXIpO1xufVxuXG4vKipcbiAqIEludGVybmFsIGxvZ2ljIHVzZWQgdG8gY29tcGlsZSBhIGBzZXRDbGFzc01ldGFkYXRhQXN5bmNgIGNhbGwuXG4gKiBAcGFyYW0gbWV0YWRhdGEgQ2xhc3MgbWV0YWRhdGEgZm9yIHRoZSBpbnRlcm5hbCBgc2V0Q2xhc3NNZXRhZGF0YWAgY2FsbC5cbiAqIEBwYXJhbSB3cmFwcGVyUGFyYW1zIFBhcmFtZXRlcnMgdG8gYmUgc2V0IG9uIHRoZSBjYWxsYmFjayB0aGF0IHdyYXBzIGBzZXRDbGFzc01ldGF0YWAuXG4gKiBAcGFyYW0gZGVwZW5kZW5jeVJlc29sdmVyRm4gRnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgZGVmZXJyZWQgZGVwZW5kZW5jaWVzLlxuICovXG5mdW5jdGlvbiBpbnRlcm5hbENvbXBpbGVTZXRDbGFzc01ldGFkYXRhQXN5bmMoXG4gICAgbWV0YWRhdGE6IFIzQ2xhc3NNZXRhZGF0YSwgd3JhcHBlclBhcmFtczogby5GblBhcmFtW10sXG4gICAgZGVwZW5kZW5jeVJlc29sdmVyRm46IG8uRXhwcmVzc2lvbik6IG8uRXhwcmVzc2lvbiB7XG4gIC8vIE9taXQgdGhlIHdyYXBwZXIgc2luY2UgaXQnbGwgYmUgYWRkZWQgYXJvdW5kIGBzZXRDbGFzc01ldGFkYXRhQXN5bmNgIGluc3RlYWQuXG4gIGNvbnN0IHNldENsYXNzTWV0YWRhdGFDYWxsID0gaW50ZXJuYWxDb21waWxlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YSk7XG4gIGNvbnN0IHNldENsYXNzTWV0YVdyYXBwZXIgPSBvLmFycm93Rm4od3JhcHBlclBhcmFtcywgW3NldENsYXNzTWV0YWRhdGFDYWxsLnRvU3RtdCgpXSk7XG4gIGNvbnN0IHNldENsYXNzTWV0YUFzeW5jID0gby5pbXBvcnRFeHByKFIzLnNldENsYXNzTWV0YWRhdGFBc3luYykuY2FsbEZuKFtcbiAgICBtZXRhZGF0YS50eXBlLCBkZXBlbmRlbmN5UmVzb2x2ZXJGbiwgc2V0Q2xhc3NNZXRhV3JhcHBlclxuICBdKTtcblxuICByZXR1cm4gby5hcnJvd0ZuKFtdLCBbZGV2T25seUd1YXJkZWRFeHByZXNzaW9uKHNldENsYXNzTWV0YUFzeW5jKS50b1N0bXQoKV0pLmNhbGxGbihbXSk7XG59XG5cbi8qKlxuICogQ29tcGlsZXMgdGhlIGZ1bmN0aW9uIHRoYXQgbG9hZHMgdGhlIGRlcGVuZGVuY2llcyBmb3IgdGhlXG4gKiBlbnRpcmUgY29tcG9uZW50IGluIGBzZXRDbGFzc01ldGFkYXRhQXN5bmNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZUNvbXBvbmVudE1ldGFkYXRhQXN5bmNSZXNvbHZlcihcbiAgICBkZXBlbmRlbmNpZXM6IFIzRGVmZXJQZXJDb21wb25lbnREZXBlbmRlbmN5W10pOiBvLkFycm93RnVuY3Rpb25FeHByIHtcbiAgY29uc3QgZHluYW1pY0ltcG9ydHMgPSBkZXBlbmRlbmNpZXMubWFwKCh7c3ltYm9sTmFtZSwgaW1wb3J0UGF0aCwgaXNEZWZhdWx0SW1wb3J0fSkgPT4ge1xuICAgIC8vIGUuZy4gYChtKSA9PiBtLkNtcEFgXG4gICAgY29uc3QgaW5uZXJGbiA9XG4gICAgICAgIC8vIERlZmF1bHQgaW1wb3J0cyBhcmUgYWx3YXlzIGFjY2Vzc2VkIHRocm91Z2ggdGhlIGBkZWZhdWx0YCBwcm9wZXJ0eS5cbiAgICAgICAgby5hcnJvd0ZuKFxuICAgICAgICAgICAgW25ldyBvLkZuUGFyYW0oJ20nLCBvLkRZTkFNSUNfVFlQRSldLFxuICAgICAgICAgICAgby52YXJpYWJsZSgnbScpLnByb3AoaXNEZWZhdWx0SW1wb3J0ID8gJ2RlZmF1bHQnIDogc3ltYm9sTmFtZSkpO1xuXG4gICAgLy8gZS5nLiBgaW1wb3J0KCcuL2NtcC1hJykudGhlbiguLi4pYFxuICAgIHJldHVybiBuZXcgby5EeW5hbWljSW1wb3J0RXhwcihpbXBvcnRQYXRoKS5wcm9wKCd0aGVuJykuY2FsbEZuKFtpbm5lckZuXSk7XG4gIH0pO1xuXG4gIC8vIGUuZy4gYCgpID0+IFsgLi4uIF07YFxuICByZXR1cm4gby5hcnJvd0ZuKFtdLCBvLmxpdGVyYWxBcnIoZHluYW1pY0ltcG9ydHMpKTtcbn1cbiJdfQ==