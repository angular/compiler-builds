/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as o from '../../../../output/output_ast';
import * as ir from '../../ir';
/**
 * The escape sequence used indicate message param values.
 */
const ESCAPE = '\uFFFD';
/**
 * Marker used to indicate an element tag.
 */
const ELEMENT_MARKER = '#';
/**
 * Marker used to indicate a template tag.
 */
const TEMPLATE_MARKER = '*';
/**
 * Marker used to indicate closing of an element or template tag.
 */
const TAG_CLOSE_MARKER = '/';
/**
 * Marker used to indicate the sub-template context.
 */
const CONTEXT_MARKER = ':';
/**
 * Marker used to indicate the start of a list of values.
 */
const LIST_START_MARKER = '[';
/**
 * Marker used to indicate the end of a list of values.
 */
const LIST_END_MARKER = ']';
/**
 * Delimiter used to separate multiple values in a list.
 */
const LIST_DELIMITER = '|';
/**
 * Formats the param maps on extracted message ops into a maps of `Expression` objects that can be
 * used in the final output.
 */
export function extractI18nMessages(job) {
    // Save the i18n context ops for later use.
    const i18nContexts = new Map();
    // Record which contexts represent i18n blocks (any other contexts are assumed to have been
    // created from ICUs).
    const i18nBlockContexts = new Set();
    for (const unit of job.units) {
        for (const op of unit.create) {
            switch (op.kind) {
                case ir.OpKind.I18nContext:
                    i18nContexts.set(op.xref, op);
                    break;
                case ir.OpKind.I18nStart:
                    i18nBlockContexts.add(op.context);
                    break;
            }
        }
    }
    // Extract messages from root i18n blocks.
    const i18nBlockMessages = new Map();
    for (const unit of job.units) {
        for (const op of unit.create) {
            if (op.kind === ir.OpKind.I18nStart && op.xref === op.root) {
                if (!op.context) {
                    throw Error('I18n start op should have its context set.');
                }
                const i18nMessageOp = createI18nMessage(job, i18nContexts.get(op.context));
                i18nBlockMessages.set(op.xref, i18nMessageOp);
                unit.create.push(i18nMessageOp);
            }
        }
    }
    // Extract messages from ICUs with their own sub-context.
    for (const unit of job.units) {
        for (const op of unit.create) {
            switch (op.kind) {
                case ir.OpKind.IcuStart:
                    if (!op.context) {
                        throw Error('ICU op should have its context set.');
                    }
                    if (!i18nBlockContexts.has(op.context)) {
                        const i18nContext = i18nContexts.get(op.context);
                        const subMessage = createI18nMessage(job, i18nContext, op.messagePlaceholder);
                        unit.create.push(subMessage);
                        const parentMessage = i18nBlockMessages.get(i18nContext.i18nBlock);
                        parentMessage?.subMessages.push(subMessage.xref);
                    }
                    ir.OpList.remove(op);
                    break;
                case ir.OpKind.IcuEnd:
                    ir.OpList.remove(op);
                    break;
            }
        }
    }
}
/**
 * Create an i18n message op from an i18n context op.
 */
function createI18nMessage(job, context, messagePlaceholder) {
    let needsPostprocessing = context.postprocessingParams.size > 0;
    for (const values of context.params.values()) {
        if (values.length > 1) {
            needsPostprocessing = true;
        }
    }
    return ir.createI18nMessageOp(job.allocateXrefId(), context.i18nBlock, context.message, messagePlaceholder ?? null, formatParams(context.params), formatParams(context.postprocessingParams), needsPostprocessing);
}
/**
 * Formats a map of `I18nParamValue[]` values into a map of `Expression` values.
 */
function formatParams(params) {
    const result = new Map();
    for (const [placeholder, placeholderValues] of params) {
        const serializedValues = formatParamValues(placeholderValues);
        if (serializedValues !== null) {
            result.set(placeholder, o.literal(formatParamValues(placeholderValues)));
        }
    }
    return result;
}
/**
 * Formats an `I18nParamValue[]` into a string (or null for empty array).
 */
function formatParamValues(values) {
    if (values.length === 0) {
        return null;
    }
    const serializedValues = values.map(value => formatValue(value));
    return serializedValues.length === 1 ?
        serializedValues[0] :
        `${LIST_START_MARKER}${serializedValues.join(LIST_DELIMITER)}${LIST_END_MARKER}`;
}
/**
 * Formats a single `I18nParamValue` into a string
 */
function formatValue(value) {
    // If there are no special flags, just return the raw value.
    if (value.flags === ir.I18nParamValueFlags.None) {
        return `${value.value}`;
    }
    let tagMarker = '';
    let closeMarker = '';
    if (value.flags & ir.I18nParamValueFlags.ElementTag) {
        tagMarker = ELEMENT_MARKER;
    }
    else if (value.flags & ir.I18nParamValueFlags.TemplateTag) {
        tagMarker = TEMPLATE_MARKER;
    }
    if (tagMarker !== '') {
        closeMarker = value.flags & ir.I18nParamValueFlags.CloseTag ? TAG_CLOSE_MARKER : '';
    }
    const context = value.subTemplateIndex === null ? '' : `${CONTEXT_MARKER}${value.subTemplateIndex}`;
    // Self-closing tags use a special form that concatenates the start and close tag values.
    if ((value.flags & ir.I18nParamValueFlags.OpenTag) &&
        (value.flags & ir.I18nParamValueFlags.CloseTag)) {
        return `${ESCAPE}${tagMarker}${value.value}${context}${ESCAPE}${ESCAPE}${closeMarker}${tagMarker}${value.value}${context}${ESCAPE}`;
    }
    return `${ESCAPE}${closeMarker}${tagMarker}${value.value}${context}${ESCAPE}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmFjdF9pMThuX21lc3NhZ2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXIvc3JjL3RlbXBsYXRlL3BpcGVsaW5lL3NyYy9waGFzZXMvZXh0cmFjdF9pMThuX21lc3NhZ2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sS0FBSyxDQUFDLE1BQU0sK0JBQStCLENBQUM7QUFDbkQsT0FBTyxLQUFLLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFHL0I7O0dBRUc7QUFDSCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFFeEI7O0dBRUc7QUFDSCxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUM7QUFFM0I7O0dBRUc7QUFDSCxNQUFNLGVBQWUsR0FBRyxHQUFHLENBQUM7QUFFNUI7O0dBRUc7QUFDSCxNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztBQUU3Qjs7R0FFRztBQUNILE1BQU0sY0FBYyxHQUFHLEdBQUcsQ0FBQztBQUUzQjs7R0FFRztBQUNILE1BQU0saUJBQWlCLEdBQUcsR0FBRyxDQUFDO0FBRTlCOztHQUVHO0FBQ0gsTUFBTSxlQUFlLEdBQUcsR0FBRyxDQUFDO0FBRTVCOztHQUVHO0FBQ0gsTUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDO0FBRTNCOzs7R0FHRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxHQUFtQjtJQUNyRCwyQ0FBMkM7SUFDM0MsTUFBTSxZQUFZLEdBQUcsSUFBSSxHQUFHLEVBQStCLENBQUM7SUFDNUQsMkZBQTJGO0lBQzNGLHNCQUFzQjtJQUN0QixNQUFNLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQUFhLENBQUM7SUFDL0MsS0FBSyxNQUFNLElBQUksSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDN0IsS0FBSyxNQUFNLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFF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QkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3RGLENBQUM7SUFDRCxNQUFNLE9BQU8sR0FDVCxLQUFLLENBQUMsZ0JBQWdCLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsY0FBYyxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQ3hGLHlGQUF5RjtJQUN6RixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDO1FBQzlDLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztRQUNwRCxPQUFPLEdBQUcsTUFBTSxHQUFHLFNBQVMsR0FBRyxLQUFLLENBQUMsS0FBSyxHQUFHLE9BQU8sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLFdBQVcsR0FDaEYsU0FBUyxHQUFHLEtBQUssQ0FBQyxLQUFLLEdBQUcsT0FBTyxHQUFHLE1BQU0sRUFBRSxDQUFDO0lBQ25ELENBQUM7SUFDRCxPQUFPLEdBQUcsTUFBTSxHQUFHLFdBQVcsR0FBRyxTQUFTLEdBQUcsS0FBSyxDQUFDLEtBQUssR0FBRyxPQUFPLEdBQUcsTUFBTSxFQUFFLENBQUM7QUFDaEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyBvIGZyb20gJy4uLy4uLy4uLy4uL291dHB1dC9vdXRwdXRfYXN0JztcbmltcG9ydCAqIGFzIGlyIGZyb20gJy4uLy4uL2lyJztcbmltcG9ydCB7Q29tcGlsYXRpb25Kb2J9IGZyb20gJy4uL2NvbXBpbGF0aW9uJztcblxuLyoqXG4gKiBUaGUgZXNjYXBlIHNlcXVlbmNlIHVzZWQgaW5kaWNhdGUgbWVzc2FnZSBwYXJhbSB2YWx1ZXMuXG4gKi9cbmNvbnN0IEVTQ0FQRSA9ICdcXHVGRkZEJztcblxuLyoqXG4gKiBNYXJrZXIgdXNlZCB0byBpbmRpY2F0ZSBhbiBlbGVtZW50IHRhZy5cbiAqL1xuY29uc3QgRUxFTUVOVF9NQVJLRVIgPSAnIyc7XG5cbi8qKlxuICogTWFya2VyIHVzZWQgdG8gaW5kaWNhdGUgYSB0ZW1wbGF0ZSB0YWcuXG4gKi9cbmNvbnN0IFRFTVBMQVRFX01BUktFUiA9ICcqJztcblxuLyoqXG4gKiBNYXJrZXIgdXNlZCB0byBpbmRpY2F0ZSBjbG9zaW5nIG9mIGFuIGVsZW1lbnQgb3IgdGVtcGxhdGUgdGFnLlxuICovXG5jb25zdCBUQUdfQ0xPU0VfTUFSS0VSID0gJy8nO1xuXG4vKipcbiAqIE1hcmtlciB1c2VkIHRvIGluZGljYXRlIHRoZSBzdWItdGVtcGxhdGUgY29udGV4dC5cbiAqL1xuY29uc3QgQ09OVEVYVF9NQVJLRVIgPSAnOic7XG5cbi8qKlxuICogTWFya2VyIHVzZWQgdG8gaW5kaWNhdGUgdGhlIHN0YXJ0IG9mIGEgbGlzdCBvZiB2YWx1ZXMuXG4gKi9cbmNvbnN0IExJU1RfU1RBUlRfTUFSS0VSID0gJ1snO1xuXG4vKipcbiAqIE1hcmtlciB1c2VkIHRvIGluZGljYXRlIHRoZSBlbmQgb2YgYSBsaXN0IG9mIHZhbHVlcy5cbiAqL1xuY29uc3QgTElTVF9FTkRfTUFSS0VSID0gJ10nO1xuXG4vKipcbiAqIERlbGltaXRlciB1c2VkIHRvIHNlcGFyYXRlIG11bHRpcGxlIHZhbHVlcyBpbiBhIGxpc3QuXG4gKi9cbmNvbnN0IExJU1RfREVMSU1JVEVSID0gJ3wnO1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIHBhcmFtIG1hcHMgb24gZXh0cmFjdGVkIG1lc3NhZ2Ugb3BzIGludG8gYSBtYXBzIG9mIGBFeHByZXNzaW9uYCBvYmplY3RzIHRoYXQgY2FuIGJlXG4gKiB1c2VkIGluIHRoZSBmaW5hbCBvdXRwdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0STE4bk1lc3NhZ2VzKGpvYjogQ29tcGlsYXRpb25Kb2IpOiB2b2lkIHtcbiAgLy8gU2F2ZSB0aGUgaTE4biBjb250ZXh0IG9wcyBmb3IgbGF0ZXIgdXNlLlxuICBjb25zdCBpMThuQ29udGV4dHMgPSBuZXcgTWFwPGlyLlhyZWZJZCwgaXIuSTE4bkNvbnRleHRPcD4oKTtcbiAgLy8gUmVjb3JkIHdoaWNoIGNvbnRleHRzIHJlcHJlc2VudCBpMThuIGJsb2NrcyAoYW55IG90aGVyIGNvbnRleHRzIGFyZSBhc3N1bWVkIHRvIGhhdmUgYmVlblxuICAvLyBjcmVhdGVkIGZyb20gSUNVcykuXG4gIGNvbnN0IGkxOG5CbG9ja0NvbnRleHRzID0gbmV3IFNldDxpci5YcmVmSWQ+KCk7XG4gIGZvciAoY29uc3QgdW5pdCBvZiBqb2IudW5pdHMpIHtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHVuaXQuY3JlYXRlKSB7XG4gICAgICBzd2l0Y2ggKG9wLmtpbmQpIHtcbiAgICAgICAgY2FzZSBpci5PcEtpbmQuSTE4bkNvbnRleHQ6XG4gICAgICAgICAgaTE4bkNvbnRleHRzLnNldChvcC54cmVmLCBvcCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaXIuT3BLaW5kLkkxOG5TdGFydDpcbiAgICAgICAgICBpMThuQmxvY2tDb250ZXh0cy5hZGQob3AuY29udGV4dCEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4dHJhY3QgbWVzc2FnZXMgZnJvbSByb290IGkxOG4gYmxvY2tzLlxuICBjb25zdCBpMThuQmxvY2tNZXNzYWdlcyA9IG5ldyBNYXA8aXIuWHJlZklkLCBpci5JMThuTWVzc2FnZU9wPigpO1xuICBmb3IgKGNvbnN0IHVuaXQgb2Ygam9iLnVuaXRzKSB7XG4gICAgZm9yIChjb25zdCBvcCBvZiB1bml0LmNyZWF0ZSkge1xuICAgICAgaWYgKG9wLmtpbmQgPT09IGlyLk9wS2luZC5JMThuU3RhcnQgJiYgb3AueHJlZiA9PT0gb3Aucm9vdCkge1xuICAgICAgICBpZiAoIW9wLmNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSTE4biBzdGFydCBvcCBzaG91bGQgaGF2ZSBpdHMgY29udGV4dCBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaTE4bk1lc3NhZ2VPcCA9IGNyZWF0ZUkxOG5NZXNzYWdlKGpvYiwgaTE4bkNvbnRleHRzLmdldChvcC5jb250ZXh0KSEpO1xuICAgICAgICBpMThuQmxvY2tNZXNzYWdlcy5zZXQob3AueHJlZiwgaTE4bk1lc3NhZ2VPcCk7XG4gICAgICAgIHVuaXQuY3JlYXRlLnB1c2goaTE4bk1lc3NhZ2VPcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRXh0cmFjdCBtZXNzYWdlcyBmcm9tIElDVXMgd2l0aCB0aGVpciBvd24gc3ViLWNvbnRleHQuXG4gIGZvciAoY29uc3QgdW5pdCBvZiBqb2IudW5pdHMpIHtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHVuaXQuY3JlYXRlKSB7XG4gICAgICBzd2l0Y2ggKG9wLmtpbmQpIHtcbiAgICAgICAgY2FzZSBpci5PcEtpbmQuSWN1U3RhcnQ6XG4gICAgICAgICAgaWYgKCFvcC5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSUNVIG9wIHNob3VsZCBoYXZlIGl0cyBjb250ZXh0IHNldC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpMThuQmxvY2tDb250ZXh0cy5oYXMob3AuY29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGkxOG5Db250ZXh0ID0gaTE4bkNvbnRleHRzLmdldChvcC5jb250ZXh0KSE7XG4gICAgICAgICAgICBjb25zdCBzdWJNZXNzYWdlID0gY3JlYXRlSTE4bk1lc3NhZ2Uoam9iLCBpMThuQ29udGV4dCwgb3AubWVzc2FnZVBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHVuaXQuY3JlYXRlLnB1c2goc3ViTWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRNZXNzYWdlID0gaTE4bkJsb2NrTWVzc2FnZXMuZ2V0KGkxOG5Db250ZXh0LmkxOG5CbG9jayk7XG4gICAgICAgICAgICBwYXJlbnRNZXNzYWdlPy5zdWJNZXNzYWdlcy5wdXNoKHN1Yk1lc3NhZ2UueHJlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlyLk9wTGlzdC5yZW1vdmU8aXIuQ3JlYXRlT3A+KG9wKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpci5PcEtpbmQuSWN1RW5kOlxuICAgICAgICAgIGlyLk9wTGlzdC5yZW1vdmU8aXIuQ3JlYXRlT3A+KG9wKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gaTE4biBtZXNzYWdlIG9wIGZyb20gYW4gaTE4biBjb250ZXh0IG9wLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZShcbiAgICBqb2I6IENvbXBpbGF0aW9uSm9iLCBjb250ZXh0OiBpci5JMThuQ29udGV4dE9wLCBtZXNzYWdlUGxhY2Vob2xkZXI/OiBzdHJpbmcpOiBpci5JMThuTWVzc2FnZU9wIHtcbiAgbGV0IG5lZWRzUG9zdHByb2Nlc3NpbmcgPSBjb250ZXh0LnBvc3Rwcm9jZXNzaW5nUGFyYW1zLnNpemUgPiAwO1xuICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBjb250ZXh0LnBhcmFtcy52YWx1ZXMoKSkge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgbmVlZHNQb3N0cHJvY2Vzc2luZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpci5jcmVhdGVJMThuTWVzc2FnZU9wKFxuICAgICAgam9iLmFsbG9jYXRlWHJlZklkKCksIGNvbnRleHQuaTE4bkJsb2NrLCBjb250ZXh0Lm1lc3NhZ2UsIG1lc3NhZ2VQbGFjZWhvbGRlciA/PyBudWxsLFxuICAgICAgZm9ybWF0UGFyYW1zKGNvbnRleHQucGFyYW1zKSwgZm9ybWF0UGFyYW1zKGNvbnRleHQucG9zdHByb2Nlc3NpbmdQYXJhbXMpLFxuICAgICAgbmVlZHNQb3N0cHJvY2Vzc2luZyk7XG59XG5cbi8qKlxuICogRm9ybWF0cyBhIG1hcCBvZiBgSTE4blBhcmFtVmFsdWVbXWAgdmFsdWVzIGludG8gYSBtYXAgb2YgYEV4cHJlc3Npb25gIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0UGFyYW1zKHBhcmFtczogTWFwPHN0cmluZywgaXIuSTE4blBhcmFtVmFsdWVbXT4pOiBNYXA8c3RyaW5nLCBvLkV4cHJlc3Npb24+IHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcDxzdHJpbmcsIG8uRXhwcmVzc2lvbj4oKTtcbiAgZm9yIChjb25zdCBbcGxhY2Vob2xkZXIsIHBsYWNlaG9sZGVyVmFsdWVzXSBvZiBwYXJhbXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWVzID0gZm9ybWF0UGFyYW1WYWx1ZXMocGxhY2Vob2xkZXJWYWx1ZXMpO1xuICAgIGlmIChzZXJpYWxpemVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQuc2V0KHBsYWNlaG9sZGVyLCBvLmxpdGVyYWwoZm9ybWF0UGFyYW1WYWx1ZXMocGxhY2Vob2xkZXJWYWx1ZXMpKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRm9ybWF0cyBhbiBgSTE4blBhcmFtVmFsdWVbXWAgaW50byBhIHN0cmluZyAob3IgbnVsbCBmb3IgZW1wdHkgYXJyYXkpLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXJhbVZhbHVlcyh2YWx1ZXM6IGlyLkkxOG5QYXJhbVZhbHVlW10pOiBzdHJpbmd8bnVsbCB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2VyaWFsaXplZFZhbHVlcyA9IHZhbHVlcy5tYXAodmFsdWUgPT4gZm9ybWF0VmFsdWUodmFsdWUpKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZWRWYWx1ZXMubGVuZ3RoID09PSAxID9cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZXNbMF0gOlxuICAgICAgYCR7TElTVF9TVEFSVF9NQVJLRVJ9JHtzZXJpYWxpemVkVmFsdWVzLmpvaW4oTElTVF9ERUxJTUlURVIpfSR7TElTVF9FTkRfTUFSS0VSfWA7XG59XG5cbi8qKlxuICogRm9ybWF0cyBhIHNpbmdsZSBgSTE4blBhcmFtVmFsdWVgIGludG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWU6IGlyLkkxOG5QYXJhbVZhbHVlKTogc3RyaW5nIHtcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIHNwZWNpYWwgZmxhZ3MsIGp1c3QgcmV0dXJuIHRoZSByYXcgdmFsdWUuXG4gIGlmICh2YWx1ZS5mbGFncyA9PT0gaXIuSTE4blBhcmFtVmFsdWVGbGFncy5Ob25lKSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlLnZhbHVlfWA7XG4gIH1cblxuICBsZXQgdGFnTWFya2VyID0gJyc7XG4gIGxldCBjbG9zZU1hcmtlciA9ICcnO1xuICBpZiAodmFsdWUuZmxhZ3MgJiBpci5JMThuUGFyYW1WYWx1ZUZsYWdzLkVsZW1lbnRUYWcpIHtcbiAgICB0YWdNYXJrZXIgPSBFTEVNRU5UX01BUktFUjtcbiAgfSBlbHNlIGlmICh2YWx1ZS5mbGFncyAmIGlyLkkxOG5QYXJhbVZhbHVlRmxhZ3MuVGVtcGxhdGVUYWcpIHtcbiAgICB0YWdNYXJrZXIgPSBURU1QTEFURV9NQVJLRVI7XG4gIH1cbiAgaWYgKHRhZ01hcmtlciAhPT0gJycpIHtcbiAgICBjbG9zZU1hcmtlciA9IHZhbHVlLmZsYWdzICYgaXIuSTE4blBhcmFtVmFsdWVGbGFncy5DbG9zZVRhZyA/IFRBR19DTE9TRV9NQVJLRVIgOiAnJztcbiAgfVxuICBjb25zdCBjb250ZXh0ID1cbiAgICAgIHZhbHVlLnN1YlRlbXBsYXRlSW5kZXggPT09IG51bGwgPyAnJyA6IGAke0NPTlRFWFRfTUFSS0VSfSR7dmFsdWUuc3ViVGVtcGxhdGVJbmRleH1gO1xuICAvLyBTZWxmLWNsb3NpbmcgdGFncyB1c2UgYSBzcGVjaWFsIGZvcm0gdGhhdCBjb25jYXRlbmF0ZXMgdGhlIHN0YXJ0IGFuZCBjbG9zZSB0YWcgdmFsdWVzLlxuICBpZiAoKHZhbHVlLmZsYWdzICYgaXIuSTE4blBhcmFtVmFsdWVGbGFncy5PcGVuVGFnKSAmJlxuICAgICAgKHZhbHVlLmZsYWdzICYgaXIuSTE4blBhcmFtVmFsdWVGbGFncy5DbG9zZVRhZykpIHtcbiAgICByZXR1cm4gYCR7RVNDQVBFfSR7dGFnTWFya2VyfSR7dmFsdWUudmFsdWV9JHtjb250ZXh0fSR7RVNDQVBFfSR7RVNDQVBFfSR7Y2xvc2VNYXJrZXJ9JHtcbiAgICAgICAgdGFnTWFya2VyfSR7dmFsdWUudmFsdWV9JHtjb250ZXh0fSR7RVNDQVBFfWA7XG4gIH1cbiAgcmV0dXJuIGAke0VTQ0FQRX0ke2Nsb3NlTWFya2VyfSR7dGFnTWFya2VyfSR7dmFsdWUudmFsdWV9JHtjb250ZXh0fSR7RVNDQVBFfWA7XG59XG4iXX0=