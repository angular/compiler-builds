/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ir from '../../ir';
function kindTest(kind) {
    return (op) => op.kind === kind;
}
/**
 * Defines the groups based on `OpKind` that ops will be divided into, for the various create
 * binding kinds. Ops will be collected into groups, then optionally transformed, before recombining
 * the groups in the order defined here.
 */
const CREATE_ORDERING = [
    { test: op => op.kind === ir.OpKind.Listener && op.hostListener && op.isAnimationListener },
    { test: op => op.kind === ir.OpKind.Listener && !(op.hostListener && op.isAnimationListener) },
];
/**
 * As above, but for update ops.
 */
const UPDATE_ORDERING = [
    { test: op => op.kind === ir.OpKind.HostProperty && op.expression instanceof ir.Interpolation },
    { test: op => op.kind === ir.OpKind.HostProperty && !(op.expression instanceof ir.Interpolation) },
    { test: kindTest(ir.OpKind.StyleMap), transform: keepLast },
    { test: kindTest(ir.OpKind.ClassMap), transform: keepLast },
    { test: kindTest(ir.OpKind.StyleProp) },
    { test: kindTest(ir.OpKind.ClassProp) },
    { test: op => op.kind === ir.OpKind.Property && op.expression instanceof ir.Interpolation },
    { test: op => op.kind === ir.OpKind.Property && !(op.expression instanceof ir.Interpolation) },
    { test: kindTest(ir.OpKind.Attribute) },
];
/**
 * The set of all op kinds we handle in the reordering phase.
 */
const handledOpKinds = new Set([
    ir.OpKind.Listener, ir.OpKind.StyleMap, ir.OpKind.ClassMap, ir.OpKind.StyleProp,
    ir.OpKind.ClassProp, ir.OpKind.Property, ir.OpKind.HostProperty, ir.OpKind.Attribute
]);
export function phaseOrdering(job) {
    for (const unit of job.units) {
        // First, we pull out ops that need to be ordered. Then, when we encounter an op that shouldn't
        // be reordered, put the ones we've pulled so far back in the correct order. Finally, if we
        // still have ops pulled at the end, put them back in the correct order.
        // Create mode:
        let opsToOrder = [];
        for (const op of unit.create) {
            if (handledOpKinds.has(op.kind)) {
                opsToOrder.push(op);
                ir.OpList.remove(op);
            }
            else {
                ir.OpList.insertBefore(reorder(opsToOrder, CREATE_ORDERING), op);
                opsToOrder = [];
            }
        }
        unit.create.push(reorder(opsToOrder, CREATE_ORDERING));
        // Update mode:
        opsToOrder = [];
        for (const op of unit.update) {
            if (handledOpKinds.has(op.kind)) {
                opsToOrder.push(op);
                ir.OpList.remove(op);
            }
            else {
                ir.OpList.insertBefore(reorder(opsToOrder, UPDATE_ORDERING), op);
                opsToOrder = [];
            }
        }
        unit.update.push(reorder(opsToOrder, UPDATE_ORDERING));
    }
}
/**
 * Reorders the given list of ops according to the ordering defined by `ORDERING`.
 */
function reorder(ops, ordering) {
    // Break the ops list into groups based on OpKind.
    const groups = Array.from(ordering, () => new Array());
    for (const op of ops) {
        const groupIndex = ordering.findIndex(o => o.test(op));
        groups[groupIndex].push(op);
    }
    // Reassemble the groups into a single list, in the correct order.
    return groups.flatMap((group, i) => {
        const transform = ordering[i].transform;
        return transform ? transform(group) : group;
    });
}
/**
 * Keeps only the last op in a list of ops.
 */
function keepLast(ops) {
    return ops.slice(ops.length - 1);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JkZXJpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci9zcmMvdGVtcGxhdGUvcGlwZWxpbmUvc3JjL3BoYXNlcy9vcmRlcmluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEtBQUssRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUcvQixTQUFTLFFBQVEsQ0FBQyxJQUFlO0lBQy9CLE9BQU8sQ0FBQyxFQUFlLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDO0FBQy9DLENBQUM7QUFPRDs7OztHQUlHO0FBQ0gsTUFBTSxlQUFlLEdBQTZCO0lBQ2hELEVBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQyxtQkFBbUIsRUFBQztJQUN6RixFQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLG1CQUFtQixDQUFDLEVBQUM7Q0FDN0YsQ0FBQztBQUVGOztHQUVHO0FBQ0gsTUFBTSxlQUFlLEdBQTZCO0lBQ2hELEVBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsTUFBTSxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsVUFBVSxZQUFZLEVBQUUsQ0FBQyxhQUFhLEVBQUM7SUFDN0YsRUFBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxNQUFNLENB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LENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNuQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGlyIGZyb20gJy4uLy4uL2lyJztcbmltcG9ydCB0eXBlIHtDb21waWxhdGlvbkpvYn0gZnJvbSAnLi4vY29tcGlsYXRpb24nO1xuXG5mdW5jdGlvbiBraW5kVGVzdChraW5kOiBpci5PcEtpbmQpOiAob3A6IGlyLlVwZGF0ZU9wKSA9PiBib29sZWFuIHtcbiAgcmV0dXJuIChvcDogaXIuVXBkYXRlT3ApID0+IG9wLmtpbmQgPT09IGtpbmQ7XG59XG5cbmludGVyZmFjZSBSdWxlPFQgZXh0ZW5kcyBpci5DcmVhdGVPcHxpci5VcGRhdGVPcD4ge1xuICB0ZXN0OiAob3A6IFQpID0+IGJvb2xlYW47XG4gIHRyYW5zZm9ybT86IChvcHM6IEFycmF5PFQ+KSA9PiBBcnJheTxUPjtcbn1cblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBncm91cHMgYmFzZWQgb24gYE9wS2luZGAgdGhhdCBvcHMgd2lsbCBiZSBkaXZpZGVkIGludG8sIGZvciB0aGUgdmFyaW91cyBjcmVhdGVcbiAqIGJpbmRpbmcga2luZHMuIE9wcyB3aWxsIGJlIGNvbGxlY3RlZCBpbnRvIGdyb3VwcywgdGhlbiBvcHRpb25hbGx5IHRyYW5zZm9ybWVkLCBiZWZvcmUgcmVjb21iaW5pbmdcbiAqIHRoZSBncm91cHMgaW4gdGhlIG9yZGVyIGRlZmluZWQgaGVyZS5cbiAqL1xuY29uc3QgQ1JFQVRFX09SREVSSU5HOiBBcnJheTxSdWxlPGlyLkNyZWF0ZU9wPj4gPSBbXG4gIHt0ZXN0OiBvcCA9PiBvcC5raW5kID09PSBpci5PcEtpbmQuTGlzdGVuZXIgJiYgb3AuaG9zdExpc3RlbmVyICYmIG9wLmlzQW5pbWF0aW9uTGlzdGVuZXJ9LFxuICB7dGVzdDogb3AgPT4gb3Aua2luZCA9PT0gaXIuT3BLaW5kLkxpc3RlbmVyICYmICEob3AuaG9zdExpc3RlbmVyICYmIG9wLmlzQW5pbWF0aW9uTGlzdGVuZXIpfSxcbl07XG5cbi8qKlxuICogQXMgYWJvdmUsIGJ1dCBmb3IgdXBkYXRlIG9wcy5cbiAqL1xuY29uc3QgVVBEQVRFX09SREVSSU5HOiBBcnJheTxSdWxlPGlyLlVwZGF0ZU9wPj4gPSBbXG4gIHt0ZXN0OiBvcCA9PiBvcC5raW5kID09PSBpci5PcEtpbmQuSG9zdFByb3BlcnR5ICYmIG9wLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBpci5JbnRlcnBvbGF0aW9ufSxcbiAge3Rlc3Q6IG9wID0+IG9wLmtpbmQgPT09IGlyLk9wS2luZC5Ib3N0UHJvcGVydHkgJiYgIShvcC5leHByZXNzaW9uIGluc3RhbmNlb2YgaXIuSW50ZXJwb2xhdGlvbil9LFxuICB7dGVzdDoga2luZFRlc3QoaXIuT3BLaW5kLlN0eWxlTWFwKSwgdHJhbnNmb3JtOiBrZWVwTGFzdH0sXG4gIHt0ZXN0OiBraW5kVGVzdChpci5PcEtpbmQuQ2xhc3NNYXApLCB0cmFuc2Zvcm06IGtlZXBMYXN0fSxcbiAge3Rlc3Q6IGtpbmRUZXN0KGlyLk9wS2luZC5TdHlsZVByb3ApfSxcbiAge3Rlc3Q6IGtpbmRUZXN0KGlyLk9wS2luZC5DbGFzc1Byb3ApfSxcbiAge3Rlc3Q6IG9wID0+IG9wLmtpbmQgPT09IGlyLk9wS2luZC5Qcm9wZXJ0eSAmJiBvcC5leHByZXNzaW9uIGluc3RhbmNlb2YgaXIuSW50ZXJwb2xhdGlvbn0sXG4gIHt0ZXN0OiBvcCA9PiBvcC5raW5kID09PSBpci5PcEtpbmQuUHJvcGVydHkgJiYgIShvcC5leHByZXNzaW9uIGluc3RhbmNlb2YgaXIuSW50ZXJwb2xhdGlvbil9LFxuICB7dGVzdDoga2luZFRlc3QoaXIuT3BLaW5kLkF0dHJpYnV0ZSl9LFxuXTtcblxuLyoqXG4gKiBUaGUgc2V0IG9mIGFsbCBvcCBraW5kcyB3ZSBoYW5kbGUgaW4gdGhlIHJlb3JkZXJpbmcgcGhhc2UuXG4gKi9cbmNvbnN0IGhhbmRsZWRPcEtpbmRzID0gbmV3IFNldChbXG4gIGlyLk9wS2luZC5MaXN0ZW5lciwgaXIuT3BLaW5kLlN0eWxlTWFwLCBpci5PcEtpbmQuQ2xhc3NNYXAsIGlyLk9wS2luZC5TdHlsZVByb3AsXG4gIGlyLk9wS2luZC5DbGFzc1Byb3AsIGlyLk9wS2luZC5Qcm9wZXJ0eSwgaXIuT3BLaW5kLkhvc3RQcm9wZXJ0eSwgaXIuT3BLaW5kLkF0dHJpYnV0ZVxuXSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwaGFzZU9yZGVyaW5nKGpvYjogQ29tcGlsYXRpb25Kb2IpIHtcbiAgZm9yIChjb25zdCB1bml0IG9mIGpvYi51bml0cykge1xuICAgIC8vIEZpcnN0LCB3ZSBwdWxsIG91dCBvcHMgdGhhdCBuZWVkIHRvIGJlIG9yZGVyZWQuIFRoZW4sIHdoZW4gd2UgZW5jb3VudGVyIGFuIG9wIHRoYXQgc2hvdWxkbid0XG4gICAgLy8gYmUgcmVvcmRlcmVkLCBwdXQgdGhlIG9uZXMgd2UndmUgcHVsbGVkIHNvIGZhciBiYWNrIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBGaW5hbGx5LCBpZiB3ZVxuICAgIC8vIHN0aWxsIGhhdmUgb3BzIHB1bGxlZCBhdCB0aGUgZW5kLCBwdXQgdGhlbSBiYWNrIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuXG4gICAgLy8gQ3JlYXRlIG1vZGU6XG4gICAgbGV0IG9wc1RvT3JkZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHVuaXQuY3JlYXRlKSB7XG4gICAgICBpZiAoaGFuZGxlZE9wS2luZHMuaGFzKG9wLmtpbmQpKSB7XG4gICAgICAgIG9wc1RvT3JkZXIucHVzaChvcCk7XG4gICAgICAgIGlyLk9wTGlzdC5yZW1vdmUob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXIuT3BMaXN0Lmluc2VydEJlZm9yZShyZW9yZGVyKG9wc1RvT3JkZXIsIENSRUFURV9PUkRFUklORyksIG9wKTtcbiAgICAgICAgb3BzVG9PcmRlciA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICB1bml0LmNyZWF0ZS5wdXNoKHJlb3JkZXIob3BzVG9PcmRlciwgQ1JFQVRFX09SREVSSU5HKSk7XG5cblxuICAgIC8vIFVwZGF0ZSBtb2RlOlxuICAgIG9wc1RvT3JkZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHVuaXQudXBkYXRlKSB7XG4gICAgICBpZiAoaGFuZGxlZE9wS2luZHMuaGFzKG9wLmtpbmQpKSB7XG4gICAgICAgIG9wc1RvT3JkZXIucHVzaChvcCk7XG4gICAgICAgIGlyLk9wTGlzdC5yZW1vdmUob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXIuT3BMaXN0Lmluc2VydEJlZm9yZShyZW9yZGVyKG9wc1RvT3JkZXIsIFVQREFURV9PUkRFUklORyksIG9wKTtcbiAgICAgICAgb3BzVG9PcmRlciA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICB1bml0LnVwZGF0ZS5wdXNoKHJlb3JkZXIob3BzVG9PcmRlciwgVVBEQVRFX09SREVSSU5HKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW9yZGVycyB0aGUgZ2l2ZW4gbGlzdCBvZiBvcHMgYWNjb3JkaW5nIHRvIHRoZSBvcmRlcmluZyBkZWZpbmVkIGJ5IGBPUkRFUklOR2AuXG4gKi9cbmZ1bmN0aW9uIHJlb3JkZXI8VCBleHRlbmRzIGlyLkNyZWF0ZU9wfGlyLlVwZGF0ZU9wPihcbiAgICBvcHM6IEFycmF5PFQ+LCBvcmRlcmluZzogQXJyYXk8UnVsZTxUPj4pOiBBcnJheTxUPiB7XG4gIC8vIEJyZWFrIHRoZSBvcHMgbGlzdCBpbnRvIGdyb3VwcyBiYXNlZCBvbiBPcEtpbmQuXG4gIGNvbnN0IGdyb3VwcyA9IEFycmF5LmZyb20ob3JkZXJpbmcsICgpID0+IG5ldyBBcnJheTxUPigpKTtcbiAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICBjb25zdCBncm91cEluZGV4ID0gb3JkZXJpbmcuZmluZEluZGV4KG8gPT4gby50ZXN0KG9wKSk7XG4gICAgZ3JvdXBzW2dyb3VwSW5kZXhdLnB1c2gob3ApO1xuICB9XG4gIC8vIFJlYXNzZW1ibGUgdGhlIGdyb3VwcyBpbnRvIGEgc2luZ2xlIGxpc3QsIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuICByZXR1cm4gZ3JvdXBzLmZsYXRNYXAoKGdyb3VwLCBpKSA9PiB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gb3JkZXJpbmdbaV0udHJhbnNmb3JtO1xuICAgIHJldHVybiB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0oZ3JvdXApIDogZ3JvdXA7XG4gIH0pO1xufVxuXG4vKipcbiAqIEtlZXBzIG9ubHkgdGhlIGxhc3Qgb3AgaW4gYSBsaXN0IG9mIG9wcy5cbiAqL1xuZnVuY3Rpb24ga2VlcExhc3Q8VD4ob3BzOiBBcnJheTxUPikge1xuICByZXR1cm4gb3BzLnNsaWNlKG9wcy5sZW5ndGggLSAxKTtcbn1cbiJdfQ==