{"version":3,"sources":["../../../../../modules/@angular/compiler/src/aot/static_symbol_resolver.ts"],"names":[],"mappings":"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","file":"static_symbol_resolver.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SummaryResolver} from '../summary_resolver';\nimport {ValueTransformer, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {isNgFactoryFile} from './util';\nexport class ResolvedStaticSymbol {\n/**\n * @param {?} symbol\n * @param {?} metadata\n */\nconstructor(public symbol: StaticSymbol,\npublic metadata: any) {}\n}\n\nfunction ResolvedStaticSymbol_tsickle_Closure_declarations() {\n/** @type {?} */\nResolvedStaticSymbol.prototype.symbol;\n/** @type {?} */\nResolvedStaticSymbol.prototype.metadata;\n}\n\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n */\nexport interface StaticSymbolResolverHost {\n  /**\n   * Return a ModuleMetadata for the given module.\n   * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n   * produced and the module has exported variables or classes with decorators. Module metadata can\n   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n   *\n   * @param modulePath is a string identifier for a module as an absolute path.\n   * @returns the metadata for the given module.\n   */\n  getMetadataFor(modulePath: string): {[key: string]: any}[];\n\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e.\n   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile: string): string /*|null*/;\n}\n\nconst /** @type {?} */ SUPPORTED_SCHEMA_VERSION = 3;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n * \n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nexport class StaticSymbolResolver {\nprivate metadataCache = new Map<string, {[key: string]: any}>();\nprivate resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\nprivate resolvedFilePaths = new Set<string>();\nprivate importAs = new Map<StaticSymbol, StaticSymbol>();\n/**\n * @param {?} host\n * @param {?} staticSymbolCache\n * @param {?} summaryResolver\n * @param {?=} errorRecorder\n */\nconstructor(\nprivate host: StaticSymbolResolverHost,\nprivate staticSymbolCache: StaticSymbolCache,\nprivate summaryResolver: SummaryResolver<StaticSymbol>,\nprivate errorRecorder?: (error: any, fileName: string) => void) {}\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nresolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    if (staticSymbol.members.length > 0) {\n      return this._resolveSymbolMembers(staticSymbol);\n    }\n    let /** @type {?} */ result = this.resolvedSymbols.get(staticSymbol);\n    if (result) {\n      return result;\n    }\n    result = this._resolveSymbolFromSummary(staticSymbol);\n    if (result) {\n      return result;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    this._createSymbolsOf(staticSymbol.filePath);\n    result = this.resolvedSymbols.get(staticSymbol);\n    return result;\n  }\n/**\n * getImportAs produces a symbol that can be used to import the given symbol.\n * The import might be different than the symbol if the symbol is exported from\n * a library with a summary; in which case we want to import the symbol from the\n * ngfactory re-export instead of directly to avoid introducing a direct dependency\n * on an otherwise indirect dependency.\n * \n * @param {?} staticSymbol the symbol for which to generate a import symbol\n * @return {?}\n */\ngetImportAs(staticSymbol: StaticSymbol): StaticSymbol {\n    if (staticSymbol.members.length) {\n      const /** @type {?} */ baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n      const /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n      return baseImportAs ?\n          this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n          null;\n    }\n    let /** @type {?} */ result = this.summaryResolver.getImportAs(staticSymbol);\n    if (!result) {\n      result = this.importAs.get(staticSymbol);\n    }\n    return result;\n  }\n/**\n * getTypeArity returns the number of generic type parameters the given symbol\n * has. If the symbol is not a type the result is null.\n * @param {?} staticSymbol\n * @return {?}\n */\ngetTypeArity(staticSymbol: StaticSymbol): number /*|null*/ {\n    // If the file is a factory file, don't resolve the symbol as doing so would\n    // cause the metadata for an factory file to be loaded which doesn't exist.\n    // All references to generated classes must include the correct arity whenever\n    // generating code.\n    if (isNgFactoryFile(staticSymbol.filePath)) {\n      return null;\n    }\n    let /** @type {?} */ resolvedSymbol = this.resolveSymbol(staticSymbol);\n    while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n      resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);\n    }\n    return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} targetSymbol\n * @return {?}\n */\nrecordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol) {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    this.importAs.set(sourceSymbol, targetSymbol);\n  }\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nprivate _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    const /** @type {?} */ members = staticSymbol.members;\n    const /** @type {?} */ baseResolvedSymbol =\n        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n    if (!baseResolvedSymbol) {\n      return null;\n    }\n    const /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n    if (baseMetadata instanceof StaticSymbol) {\n      return new ResolvedStaticSymbol(\n          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n      if (baseMetadata.statics && members.length === 1) {\n        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n      }\n    } else {\n      let /** @type {?} */ value = baseMetadata;\n      for (let /** @type {?} */ i = 0; i < members.length && value; i++) {\n        value = value[members[i]];\n      }\n      return new ResolvedStaticSymbol(staticSymbol, value);\n    }\n    return null;\n  }\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nprivate _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    const /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n  }\n/**\n * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n * All types passed to the StaticResolver should be pseudo-types returned by this method.\n * \n * @param {?} declarationFile the absolute path of the file where the symbol is declared\n * @param {?} name the name of the type.\n * @param {?=} members a symbol for a static member of the named type\n * @return {?}\n */\ngetStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.staticSymbolCache.get(declarationFile, name, members);\n  }\n/**\n * @param {?} filePath\n * @return {?}\n */\ngetSymbolsOf(filePath: string): StaticSymbol[] {\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    let /** @type {?} */ symbols = new Set<StaticSymbol>(this.summaryResolver.getSymbolsOf(filePath));\n    this._createSymbolsOf(filePath);\n    this.resolvedSymbols.forEach((resolvedSymbol) => {\n      if (resolvedSymbol.symbol.filePath === filePath) {\n        symbols.add(resolvedSymbol.symbol);\n      }\n    });\n    return Array.from(symbols);\n  }\n/**\n * @param {?} filePath\n * @return {?}\n */\nprivate _createSymbolsOf(filePath: string) {\n    if (this.resolvedFilePaths.has(filePath)) {\n      return;\n    }\n    this.resolvedFilePaths.add(filePath);\n    const /** @type {?} */ resolvedSymbols: ResolvedStaticSymbol[] = [];\n    const /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n    if (metadata['metadata']) {\n      // handle direct declarations of the symbol\n      const /** @type {?} */ topLevelSymbolNames =\n          new Set<string>(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n      Object.keys(metadata['metadata']).forEach((metadataKey) => {\n        const /** @type {?} */ symbolMeta = metadata['metadata'][metadataKey];\n        const /** @type {?} */ name = unescapeIdentifier(metadataKey);\n        const /** @type {?} */ canonicalSymbol = this.getStaticSymbol(filePath, name);\n        if (metadata['importAs']) {\n          // Index bundle indexes should use the importAs module name instead of a reference\n          // to the .d.ts file directly.\n          const /** @type {?} */ importSymbol = this.getStaticSymbol(metadata['importAs'], name);\n          this.recordImportAs(canonicalSymbol, importSymbol);\n        }\n        resolvedSymbols.push(\n            this.createResolvedSymbol(canonicalSymbol, topLevelSymbolNames, symbolMeta));\n      });\n    }\n\n    // handle the symbols in one of the re-export location\n    if (metadata['exports']) {\n      for (const /** @type {?} */ moduleExport of metadata['exports']) {\n        // handle the symbols in the list of explicitly re-exported symbols.\n        if (moduleExport.export) {\n          moduleExport.export.forEach((exportSymbol: any) => {\n            let /** @type {?} */ symbolName: string;\n            if (typeof exportSymbol === 'string') {\n              symbolName = exportSymbol;\n            } else {\n              symbolName = exportSymbol.as;\n            }\n            symbolName = unescapeIdentifier(symbolName);\n            let /** @type {?} */ symName = symbolName;\n            if (typeof exportSymbol !== 'string') {\n              symName = unescapeIdentifier(exportSymbol.name);\n            }\n            const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n            if (resolvedModule) {\n              const /** @type {?} */ targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n              const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            }\n          });\n        } else {\n          // handle the symbols via export * directives.\n          const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n          if (resolvedModule) {\n            const /** @type {?} */ nestedExports = this.getSymbolsOf(resolvedModule);\n            nestedExports.forEach((targetSymbol) => {\n              const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            });\n          }\n        }\n      }\n    }\n    resolvedSymbols.forEach(\n        (resolvedSymbol) => this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol));\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} topLevelSymbolNames\n * @param {?} metadata\n * @return {?}\n */\nprivate createResolvedSymbol(\n      sourceSymbol: StaticSymbol, topLevelSymbolNames: Set<string>,\n      metadata: any): ResolvedStaticSymbol {\n    const /** @type {?} */ self = this;\nclass ReferenceTransformer extends ValueTransformer {\n/**\n * @param {?} map\n * @param {?} functionParams\n * @return {?}\n */\nvisitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n        const /** @type {?} */ symbolic = map['__symbolic'];\n        if (symbolic === 'function') {\n          const /** @type {?} */ oldLen = functionParams.length;\n          functionParams.push(...(map['parameters'] || []));\n          const /** @type {?} */ result = super.visitStringMap(map, functionParams);\n          functionParams.length = oldLen;\n          return result;\n        } else if (symbolic === 'reference') {\n          const /** @type {?} */ module = map['module'];\n          const /** @type {?} */ name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n          if (!name) {\n            return null;\n          }\n          let /** @type {?} */ filePath: string;\n          if (module) {\n            filePath = self.resolveModule(module, sourceSymbol.filePath);\n            if (!filePath) {\n              return {\n                __symbolic: 'error',\n                message: `Could not resolve ${module} relative to ${sourceSymbol.filePath}.`\n              };\n            }\n            return self.getStaticSymbol(filePath, name);\n          } else if (functionParams.indexOf(name) >= 0) {\n            // reference to a function parameter\n            return {__symbolic: 'reference', name: name};\n          } else {\n            if (topLevelSymbolNames.has(name)) {\n              return self.getStaticSymbol(sourceSymbol.filePath, name);\n            }\n            // ambient value\n            null;\n          }\n        } else {\n          return super.visitStringMap(map, functionParams);\n        }\n      }\n    }\n    const /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n    if (transformedMeta instanceof StaticSymbol) {\n      return this.createExport(sourceSymbol, transformedMeta);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} targetSymbol\n * @return {?}\n */\nprivate createExport(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol):\n      ResolvedStaticSymbol {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath)) {\n      // This case is for an ng library importing symbols from a plain ts library\n      // transitively.\n      // Note: We rely on the fact that we discover symbols in the direction\n      // from source files to library files\n      this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n  }\n/**\n * @param {?} error\n * @param {?} context\n * @param {?=} path\n * @return {?}\n */\nprivate reportError(error: Error, context: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(error, (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n/**\n * @param {?} module an absolute path to a module file.\n * @return {?}\n */\nprivate getModuleMetadata(module: string): {[key: string]: any} {\n    let /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n    if (!moduleMetadata) {\n      const /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n      if (moduleMetadatas) {\n        let /** @type {?} */ maxVersion = -1;\n        moduleMetadatas.forEach((md) => {\n          if (md['version'] > maxVersion) {\n            maxVersion = md['version'];\n            moduleMetadata = md;\n          }\n        });\n      }\n      if (!moduleMetadata) {\n        moduleMetadata =\n            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n      }\n      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n        const /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n            `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\n            `Metadata version mismatch for module ${module}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n        this.reportError(new Error(errorMessage), null);\n      }\n      this.metadataCache.set(module, moduleMetadata);\n    }\n    return moduleMetadata;\n  }\n/**\n * @param {?} module\n * @param {?} symbolName\n * @param {?=} containingFile\n * @return {?}\n */\ngetSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n    const /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n    if (!filePath) {\n      this.reportError(\n          new Error(`Could not resolve module ${module}${containingFile ? ` relative to $ {\n            containingFile\n          } `: ''}`),\n          null);\n      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n    }\n    return this.getStaticSymbol(filePath, symbolName);\n  }\n/**\n * @param {?} module\n * @param {?} containingFile\n * @return {?}\n */\nprivate resolveModule(module: string, containingFile: string): string {\n    try {\n      return this.host.moduleNameToFileName(module, containingFile);\n    } catch ( /** @type {?} */e) {\n      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n      this.reportError(e, null, containingFile);\n    }\n  }\n}\n\nfunction StaticSymbolResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nStaticSymbolResolver.prototype.metadataCache;\n/** @type {?} */\nStaticSymbolResolver.prototype.resolvedSymbols;\n/** @type {?} */\nStaticSymbolResolver.prototype.resolvedFilePaths;\n/** @type {?} */\nStaticSymbolResolver.prototype.importAs;\n/** @type {?} */\nStaticSymbolResolver.prototype.host;\n/** @type {?} */\nStaticSymbolResolver.prototype.staticSymbolCache;\n/** @type {?} */\nStaticSymbolResolver.prototype.summaryResolver;\n/** @type {?} */\nStaticSymbolResolver.prototype.errorRecorder;\n}\n\n/**\n * @param {?} identifier\n * @return {?}\n */\nexport function unescapeIdentifier(identifier: string): string {\n  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}"]}