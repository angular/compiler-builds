{"version":3,"sources":["../../../../modules/@angular/compiler/src/util.ts"],"names":[],"mappings":"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","file":"util.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isPrimitive, isStrictStringMap} from './facade/lang';\nexport const /** @type {?} */ MODULE_SUFFIX = '';\n\nconst /** @type {?} */ CAMEL_CASE_REGEXP = /([A-Z])/g;\nconst /** @type {?} */ DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\nexport function camelCaseToDashCase(input: string): string {\n  return input.replace(CAMEL_CASE_REGEXP, (...m: any[]) => '-' + m[1].toLowerCase());\n}\n/**\n * @param {?} input\n * @return {?}\n */\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nexport function splitAtColon(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, ':', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nexport function splitAtPeriod(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, '.', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} character\n * @param {?} defaultValues\n * @return {?}\n */\nfunction _splitAt(input: string, character: string, defaultValues: string[]): string[] {\n  const /** @type {?} */ characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n/**\n * @param {?} value\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nexport function visitValue(value: any, visitor: ValueVisitor, context: any): any {\n  if (Array.isArray(value)) {\n    return visitor.visitArray( /** @type {?} */((<any[]>value)), context);\n  }\n\n  if (isStrictStringMap(value)) {\n    return visitor.visitStringMap( /** @type {?} */((<{[key: string]: any}>value)), context);\n  }\n\n  if (value == null || isPrimitive(value)) {\n    return visitor.visitPrimitive(value, context);\n  }\n\n  return visitor.visitOther(value, context);\n}\n\nexport interface ValueVisitor {\n  visitArray(arr: any[], context: any): any;\n  visitStringMap(map: {[key: string]: any}, context: any): any;\n  visitPrimitive(value: any, context: any): any;\n  visitOther(value: any, context: any): any;\n}\nexport class ValueTransformer implements ValueVisitor {\n/**\n * @param {?} arr\n * @param {?} context\n * @return {?}\n */\nvisitArray(arr: any[], context: any): any {\n    return arr.map(value => visitValue(value, this, context));\n  }\n/**\n * @param {?} map\n * @param {?} context\n * @return {?}\n */\nvisitStringMap(map: {[key: string]: any}, context: any): any {\n    const /** @type {?} */ result: {[key: string]: any} = {};\n    Object.keys(map).forEach(key => { result[key] = visitValue(map[key], this, context); });\n    return result;\n  }\n/**\n * @param {?} value\n * @param {?} context\n * @return {?}\n */\nvisitPrimitive(value: any, context: any): any { return value; }\n/**\n * @param {?} value\n * @param {?} context\n * @return {?}\n */\nvisitOther(value: any, context: any): any { return value; }\n}\nexport class SyncAsyncResult<T> {\n/**\n * @param {?} syncResult\n * @param {?=} asyncResult\n */\nconstructor(public syncResult: T,\npublic asyncResult: Promise<T> = null) {\n    if (!asyncResult) {\n      this.asyncResult = Promise.resolve(syncResult);\n    }\n  }\n}\n\nfunction SyncAsyncResult_tsickle_Closure_declarations() {\n/** @type {?} */\nSyncAsyncResult.prototype.syncResult;\n/** @type {?} */\nSyncAsyncResult.prototype.asyncResult;\n}\n\n/**\n * @param {?} msg\n * @return {?}\n */\nexport function syntaxError(msg: string): Error {\n  const /** @type {?} */ error = Error(msg);\n  ( /** @type {?} */((error as any)))[ERROR_SYNTAX_ERROR] = true;\n  return error;\n}\n\nconst /** @type {?} */ ERROR_SYNTAX_ERROR = 'ngSyntaxError';\n/**\n * @param {?} error\n * @return {?}\n */\nexport function isSyntaxError(error: Error): boolean {\n  return ( /** @type {?} */((error as any)))[ERROR_SYNTAX_ERROR];\n}\n"]}