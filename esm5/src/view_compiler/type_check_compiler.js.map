{"version":3,"file":"type_check_compiler.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/view_compiler/type_check_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompilerOptions} from '../aot/compiler_options';\nimport {StaticReflector} from '../aot/static_reflector';\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompilePipeSummary} from '../compile_metadata';\nimport {BindingForm, BuiltinConverter, EventHandlerVars, LocalResolver, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins} from '../compiler_util/expression_converter';\nimport {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ParseSourceSpan} from '../parse_util';\nimport {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ProviderAst, ProviderAstType, QueryMatch, ReferenceAst, TemplateAst, TemplateAstVisitor, TextAst, VariableAst, templateVisitAll} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\n\n/**\n * Generates code that is used to type check templates.\n */\nexport class TypeCheckCompiler {\n  constructor(private options: AotCompilerOptions, private reflector: StaticReflector) {}\n\n  /**\n   * Important notes:\n   * - This must not produce new `import` statements, but only refer to types outside\n   *   of the file via the variables provided via externalReferenceVars.\n   *   This allows Typescript to reuse the old program's structure as no imports have changed.\n   * - This must not produce any exports, as this would pollute the .d.ts file\n   *   and also violate the point above.\n   */\n  compileComponent(\n      componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[],\n      usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>,\n      ctx: OutputContext): o.Statement[] {\n    const pipes = new Map<string, StaticSymbol>();\n    usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\n    let embeddedViewCount = 0;\n    const viewBuilderFactory =\n        (parent: ViewBuilder | null, guards: GuardExpression[]): ViewBuilder => {\n          const embeddedViewIndex = embeddedViewCount++;\n          return new ViewBuilder(\n              this.options, this.reflector, externalReferenceVars, parent, component.type.reference,\n              component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n        };\n\n    const visitor = viewBuilderFactory(null, []);\n    visitor.visitAll([], template);\n\n    return visitor.build(componentId);\n  }\n}\n\ninterface GuardExpression {\n  guard: StaticSymbol;\n  useIf: boolean;\n  expression: Expression;\n}\n\ninterface ViewBuilderFactory {\n  (parent: ViewBuilder, guards: GuardExpression[]): ViewBuilder;\n}\n\n// Note: This is used as key in Map and should therefore be\n// unique per value.\ntype OutputVarType = o.BuiltinTypeName | StaticSymbol;\n\ninterface Expression {\n  context: OutputVarType;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\nconst DYNAMIC_VAR_NAME = '_any';\n\nclass TypeCheckLocalResolver implements LocalResolver {\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      // References to the event should not be type-checked.\n      // TODO(chuckj): determine a better type for the event.\n      return o.variable(DYNAMIC_VAR_NAME);\n    }\n    return null;\n  }\n}\n\nconst defaultResolver = new TypeCheckLocalResolver();\n\nclass ViewBuilder implements TemplateAstVisitor, LocalResolver {\n  private refOutputVars = new Map<string, OutputVarType>();\n  private variables: VariableAst[] = [];\n  private children: ViewBuilder[] = [];\n  private updates: Expression[] = [];\n  private actions: Expression[] = [];\n\n  constructor(\n      private options: AotCompilerOptions, private reflector: StaticReflector,\n      private externalReferenceVars: Map<StaticSymbol, string>, private parent: ViewBuilder|null,\n      private component: StaticSymbol, private isHostComponent: boolean,\n      private embeddedViewIndex: number, private pipes: Map<string, StaticSymbol>,\n      private guards: GuardExpression[], private ctx: OutputContext,\n      private viewBuilderFactory: ViewBuilderFactory) {}\n\n  private getOutputVar(type: o.BuiltinTypeName|StaticSymbol): string {\n    let varName: string|undefined;\n    if (type === this.component && this.isHostComponent) {\n      varName = DYNAMIC_VAR_NAME;\n    } else if (type instanceof StaticSymbol) {\n      varName = this.externalReferenceVars.get(type);\n    } else {\n      varName = DYNAMIC_VAR_NAME;\n    }\n    if (!varName) {\n      throw new Error(\n          `Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\n    }\n    return varName;\n  }\n\n  private getTypeGuardExpressions(ast: EmbeddedTemplateAst): GuardExpression[] {\n    const result = [...this.guards];\n    for (let directive of ast.directives) {\n      for (let input of directive.inputs) {\n        const guard = directive.directive.guards[input.directiveName];\n        if (guard) {\n          const useIf = guard === 'UseIf';\n          result.push({\n            guard,\n            useIf,\n            expression: {context: this.component, value: input.value} as Expression\n          });\n        }\n      }\n    }\n    return result;\n  }\n\n  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n    this.variables = variables;\n    templateVisitAll(this, astNodes);\n  }\n\n  build(componentId: string, targetStatements: o.Statement[] = []): o.Statement[] {\n    this.children.forEach((child) => child.build(componentId, targetStatements));\n    let viewStmts: o.Statement[] =\n        [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n    let bindingCount = 0;\n    this.updates.forEach((expression) => {\n      const {sourceSpan, context, value} = this.preprocessUpdateExpression(expression);\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts, currValExpr} = convertPropertyBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n          BindingForm.General);\n      stmts.push(new o.ExpressionStatement(currValExpr));\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    this.actions.forEach(({sourceSpan, context, value}) => {\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts} = convertActionBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    if (this.guards.length) {\n      let guardExpression: o.Expression|undefined = undefined;\n      for (const guard of this.guards) {\n        const {context, value} = this.preprocessUpdateExpression(guard.expression);\n        const bindingId = `${bindingCount++}`;\n        const nameResolver = context === this.component ? this : defaultResolver;\n        // We only support support simple expressions and ignore others as they\n        // are unlikely to affect type narrowing.\n        const {stmts, currValExpr} = convertPropertyBinding(\n            nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n            BindingForm.TrySimple);\n        if (stmts.length == 0) {\n          const guardClause =\n              guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n          guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n        }\n      }\n      if (guardExpression) {\n        viewStmts = [new o.IfStmt(guardExpression, viewStmts)];\n      }\n    }\n\n    const viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\n    const viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n    targetStatements.push(viewFactory);\n    return targetStatements;\n  }\n\n  visitBoundText(ast: BoundTextAst, context: any): any {\n    const astWithSource = <ASTWithSource>ast.value;\n    const inter = <Interpolation>astWithSource.ast;\n\n    inter.expressions.forEach(\n        (expr) =>\n            this.updates.push({context: this.component, value: expr, sourceSpan: ast.sourceSpan}));\n  }\n\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n    // Note: The old view compiler used to use an `any` type\n    // for the context in any embedded view.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n      // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n      // stamped out if ngIf is truthy so any bindings in the template can assume that,\n      // if a nullable type is used for ngIf, that expression is not null or undefined.\n      const guards = this.getTypeGuardExpressions(ast);\n      const childVisitor = this.viewBuilderFactory(this, guards);\n      this.children.push(childVisitor);\n      childVisitor.visitAll(ast.variables, ast.children);\n    }\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n\n    let inputDefs: o.Expression[] = [];\n    let updateRendererExpressions: Expression[] = [];\n    let outputDefs: o.Expression[] = [];\n    ast.inputs.forEach((inputAst) => {\n      this.updates.push(\n          {context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan});\n    });\n\n    templateVisitAll(this, ast.children);\n  }\n\n  private visitElementOrTemplate(ast: {\n    outputs: BoundEventAst[],\n    directives: DirectiveAst[],\n    references: ReferenceAst[],\n  }) {\n    ast.directives.forEach((dirAst) => { this.visitDirective(dirAst); });\n\n    ast.references.forEach((ref) => {\n      let outputVarType: OutputVarType = null !;\n      // Note: The old view compiler used to use an `any` type\n      // for directives exposed via `exportAs`.\n      // We keep this behaivor behind a flag for now.\n      if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\n        outputVarType = ref.value.identifier.reference;\n      } else {\n        outputVarType = o.BuiltinTypeName.Dynamic;\n      }\n      this.refOutputVars.set(ref.name, outputVarType);\n    });\n    ast.outputs.forEach((outputAst) => {\n      this.actions.push(\n          {context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan});\n    });\n  }\n\n  visitDirective(dirAst: DirectiveAst) {\n    const dirType = dirAst.directive.type.reference;\n    dirAst.inputs.forEach(\n        (input) => this.updates.push(\n            {context: this.component, value: input.value, sourceSpan: input.sourceSpan}));\n    // Note: The old view compiler used to use an `any` type\n    // for expressions in host properties / events.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      dirAst.hostProperties.forEach(\n          (inputAst) => this.updates.push(\n              {context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan}));\n      dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\n        context: dirType,\n        value: hostEventAst.handler,\n        sourceSpan: hostEventAst.sourceSpan\n      }));\n    }\n  }\n\n  getLocal(name: string): o.Expression|null {\n    if (name == EventHandlerVars.event.name) {\n      return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n    }\n    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent) {\n      let outputVarType: OutputVarType|undefined;\n      // check references\n      outputVarType = currBuilder.refOutputVars.get(name);\n      if (outputVarType == null) {\n        // check variables\n        const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n        if (varAst) {\n          outputVarType = o.BuiltinTypeName.Dynamic;\n        }\n      }\n      if (outputVarType != null) {\n        return o.variable(this.getOutputVar(outputVarType));\n      }\n    }\n    return null;\n  }\n\n  private pipeOutputVar(name: string): string {\n    const pipe = this.pipes.get(name);\n    if (!pipe) {\n      throw new Error(\n          `Illegal State: Could not find pipe ${name} in template of ${this.component}`);\n    }\n    return this.getOutputVar(pipe);\n  }\n\n  private preprocessUpdateExpression(expression: Expression): Expression {\n    return {\n      sourceSpan: expression.sourceSpan,\n      context: expression.context,\n      value: convertPropertyBindingBuiltins(\n          {\n            createLiteralArrayConverter: (argCount: number) => (args: o.Expression[]) => {\n              const arr = o.literalArr(args);\n              // Note: The old view compiler used to use an `any` type\n              // for arrays.\n              return this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n            },\n            createLiteralMapConverter:\n                (keys: {key: string, quoted: boolean}[]) => (values: o.Expression[]) => {\n                  const entries = keys.map((k, i) => ({\n                                             key: k.key,\n                                             value: values[i],\n                                             quoted: k.quoted,\n                                           }));\n                  const map = o.literalMap(entries);\n                  // Note: The old view compiler used to use an `any` type\n                  // for maps.\n                  return this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n                },\n            createPipeConverter: (name: string, argCount: number) => (args: o.Expression[]) => {\n              // Note: The old view compiler used to use an `any` type\n              // for pipes.\n              const pipeExpr = this.options.fullTemplateTypeCheck ?\n                  o.variable(this.pipeOutputVar(name)) :\n                  o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n              return pipeExpr.callMethod('transform', args);\n            },\n          },\n          expression.value)\n    };\n  }\n\n  visitNgContent(ast: NgContentAst, context: any): any {}\n  visitText(ast: TextAst, context: any): any {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n  visitReference(ast: ReferenceAst, context: any): any {}\n  visitVariable(ast: VariableAst, context: any): any {}\n  visitEvent(ast: BoundEventAst, context: any): any {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n  visitAttr(ast: AttrAst, context: any): any {}\n}\n"]}