{"version":3,"file":"provider_compiler.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/view_compiler/provider_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDiDependencyMetadata, CompileEntryComponentMetadata, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {DepFlags, NodeFlags} from '../core';\nimport {Identifiers, createTokenForExternalReference} from '../identifiers';\nimport {LifecycleHooks} from '../lifecycle_reflector';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ProviderAst, ProviderAstType} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\nexport function providerDef(ctx: OutputContext, providerAst: ProviderAst): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  let flags = NodeFlags.None;\n  if (!providerAst.eager) {\n    flags |= NodeFlags.LazyProvider;\n  }\n  if (providerAst.providerType === ProviderAstType.PrivateService) {\n    flags |= NodeFlags.PrivateProvider;\n  }\n  if (providerAst.isModule) {\n    flags |= NodeFlags.TypeModuleProvider;\n  }\n  providerAst.lifecycleHooks.forEach((lifecycleHook) => {\n    // for regular providers, we only support ngOnDestroy\n    if (lifecycleHook === LifecycleHooks.OnDestroy ||\n        providerAst.providerType === ProviderAstType.Directive ||\n        providerAst.providerType === ProviderAstType.Component) {\n      flags |= lifecycleHookToNodeFlag(lifecycleHook);\n    }\n  });\n  const {providerExpr, flags: providerFlags, depsExpr} = providerAst.multiProvider ?\n      multiProviderDef(ctx, flags, providerAst.providers) :\n      singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);\n  return {\n    providerExpr,\n    flags: providerFlags, depsExpr,\n    tokenExpr: tokenExpr(ctx, providerAst.token),\n  };\n}\n\nfunction multiProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providers: CompileProviderMetadata[]):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  const allDepDefs: o.Expression[] = [];\n  const allParams: o.FnParam[] = [];\n  const exprs = providers.map((provider, providerIndex) => {\n    let expr: o.Expression;\n    if (provider.useClass) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n      expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n    } else if (provider.useFactory) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n      expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n    } else if (provider.useExisting) {\n      const depExprs = convertDeps(providerIndex, [{token: provider.useExisting}]);\n      expr = depExprs[0];\n    } else {\n      expr = convertValueToOutputAst(ctx, provider.useValue);\n    }\n    return expr;\n  });\n  const providerExpr =\n      o.fn(allParams, [new o.ReturnStatement(o.literalArr(exprs))], o.INFERRED_TYPE);\n  return {\n    providerExpr,\n    flags: flags | NodeFlags.TypeFactoryProvider,\n    depsExpr: o.literalArr(allDepDefs)\n  };\n\n  function convertDeps(providerIndex: number, deps: CompileDiDependencyMetadata[]) {\n    return deps.map((dep, depIndex) => {\n      const paramName = `p${providerIndex}_${depIndex}`;\n      allParams.push(new o.FnParam(paramName, o.DYNAMIC_TYPE));\n      allDepDefs.push(depDef(ctx, dep));\n      return o.variable(paramName);\n    });\n  }\n}\n\nfunction singleProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providerType: ProviderAstType,\n    providerMeta: CompileProviderMetadata):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  let providerExpr: o.Expression;\n  let deps: CompileDiDependencyMetadata[];\n  if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n    providerExpr = ctx.importExpr(providerMeta.useClass !.reference);\n    flags |= NodeFlags.TypeDirective;\n    deps = providerMeta.deps || providerMeta.useClass !.diDeps;\n  } else {\n    if (providerMeta.useClass) {\n      providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n      flags |= NodeFlags.TypeClassProvider;\n      deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    } else if (providerMeta.useFactory) {\n      providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n      flags |= NodeFlags.TypeFactoryProvider;\n      deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n    } else if (providerMeta.useExisting) {\n      providerExpr = o.NULL_EXPR;\n      flags |= NodeFlags.TypeUseExistingProvider;\n      deps = [{token: providerMeta.useExisting}];\n    } else {\n      providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n      flags |= NodeFlags.TypeValueProvider;\n      deps = [];\n    }\n  }\n  const depsExpr = o.literalArr(deps.map(dep => depDef(ctx, dep)));\n  return {providerExpr, flags, depsExpr};\n}\n\nfunction tokenExpr(ctx: OutputContext, tokenMeta: CompileTokenMetadata): o.Expression {\n  return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n                                o.literal(tokenMeta.value);\n}\n\nexport function depDef(ctx: OutputContext, dep: CompileDiDependencyMetadata): o.Expression {\n  // Note: the following fields have already been normalized out by provider_analyzer:\n  // - isAttribute, isHost\n  const expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token !);\n  let flags = DepFlags.None;\n  if (dep.isSkipSelf) {\n    flags |= DepFlags.SkipSelf;\n  }\n  if (dep.isOptional) {\n    flags |= DepFlags.Optional;\n  }\n  if (dep.isSelf) {\n    flags |= DepFlags.Self;\n  }\n  if (dep.isValue) {\n    flags |= DepFlags.Value;\n  }\n  return flags === DepFlags.None ? expr : o.literalArr([o.literal(flags), expr]);\n}\n\nexport function lifecycleHookToNodeFlag(lifecycleHook: LifecycleHooks): NodeFlags {\n  let nodeFlag = NodeFlags.None;\n  switch (lifecycleHook) {\n    case LifecycleHooks.AfterContentChecked:\n      nodeFlag = NodeFlags.AfterContentChecked;\n      break;\n    case LifecycleHooks.AfterContentInit:\n      nodeFlag = NodeFlags.AfterContentInit;\n      break;\n    case LifecycleHooks.AfterViewChecked:\n      nodeFlag = NodeFlags.AfterViewChecked;\n      break;\n    case LifecycleHooks.AfterViewInit:\n      nodeFlag = NodeFlags.AfterViewInit;\n      break;\n    case LifecycleHooks.DoCheck:\n      nodeFlag = NodeFlags.DoCheck;\n      break;\n    case LifecycleHooks.OnChanges:\n      nodeFlag = NodeFlags.OnChanges;\n      break;\n    case LifecycleHooks.OnDestroy:\n      nodeFlag = NodeFlags.OnDestroy;\n      break;\n    case LifecycleHooks.OnInit:\n      nodeFlag = NodeFlags.OnInit;\n      break;\n  }\n  return nodeFlag;\n}\n\nexport function componentFactoryResolverProviderDef(\n    reflector: CompileReflector, ctx: OutputContext, flags: NodeFlags,\n    entryComponents: CompileEntryComponentMetadata[]): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  const entryComponentFactories =\n      entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));\n  const token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n  const classMeta = {\n    diDeps: [\n      {isValue: true, value: o.literalArr(entryComponentFactories)},\n      {token: token, isSkipSelf: true, isOptional: true},\n      {token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef)},\n    ],\n    lifecycleHooks: [],\n    reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n  };\n  const {providerExpr, flags: providerFlags, depsExpr} =\n      singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token,\n        multi: false,\n        useClass: classMeta,\n      });\n  return {providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token)};\n}\n"]}