{"version":3,"file":"constant_pool.js","sourceRoot":"","sources":["../../../../packages/compiler/src/constant_pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {OutputContext, error} from './util';\n\nconst CONSTANT_PREFIX = '_c';\n\nexport const enum DefinitionKind {Injector, Directive, Component, Pipe}\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  shared: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  isConstant() { return true; }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private injectorDefinitions = new Map<any, FixupExpression>();\n  private directiveDefinitions = new Map<any, FixupExpression>();\n  private componentDefinitions = new Map<any, FixupExpression>();\n  private pipeDefinitions = new Map<any, FixupExpression>();\n\n  private nextNameIndex = 0;\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (literal instanceof o.LiteralExpr || literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(literal).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n\n    return fixup;\n  }\n\n  getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared: boolean = false):\n      o.Expression {\n    const definitions = this.definitionsOf(kind);\n    let fixup = definitions.get(type);\n    let newValue = false;\n    if (!fixup) {\n      const property = this.propertyNameOf(kind);\n      fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n      definitions.set(type, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant  and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : o.literal(null));\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : o.literal(null),\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name !, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [\n            o.StmtModifier.Final\n          ]));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string { return `${prefix}${this.nextNameIndex++}`; }\n\n  private definitionsOf(kind: DefinitionKind): Map<any, FixupExpression> {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return this.componentDefinitions;\n      case DefinitionKind.Directive:\n        return this.directiveDefinitions;\n      case DefinitionKind.Injector:\n        return this.injectorDefinitions;\n      case DefinitionKind.Pipe:\n        return this.pipeDefinitions;\n    }\n    error(`Unknown definition kind ${kind}`);\n    return this.componentDefinitions;\n  }\n\n  public propertyNameOf(kind: DefinitionKind): string {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return 'ngComponentDef';\n      case DefinitionKind.Directive:\n        return 'ngDirectiveDef';\n      case DefinitionKind.Injector:\n        return 'ngInjectorDef';\n      case DefinitionKind.Pipe:\n        return 'ngPipeDef';\n    }\n    error(`Unknown definition kind ${kind}`);\n    return '<unknown>';\n  }\n\n  private freshName(): string { return this.uniqueName(CONSTANT_PREFIX); }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${entry.key}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeMethodExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n}\n\nfunction invalid<T>(arg: o.Expression | o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${o.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}"]}